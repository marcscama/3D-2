<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>terremoti-07-2025</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<base target="_blank">
<link rel="stylesheet" type="text/css" href="./Qgis2threejs.css">
<style type="text/css">
#popup, #header, #layerpanel {
  left: 36px;
}
</style>
<script src="./threejs/three.min.js"></script>
<script src="./threejs/OrbitControls.js"></script>
<script src="./threejs/ViewHelper.js"></script>
<script src="./threejs/OutlineEffect.js"></script>
<script src="./Qgis2threejs.js"></script>
</head>
<body>
<div id="view">
  <div id="northarrow"></div>
  <div id="navigation"></div>
</div>

<!-- popup -->
<div id="popup">
  <div id="closebtn">&times;</div>
  <div id="popupbar"></div>
  <div id="popupbody">
    <div id="popupcontent"></div>

    <!-- query result -->
    <div id="queryresult">
      <table id="qr_coords_table">
        <caption>Clicked coordinates <div id="zoomtopoint" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_coords"></td></tr>
      </table>

      <table id="qr_layername_table">
        <caption>Layer <div id="zoomtolayer" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_layername"></td></tr>
      </table>

      <table id="qr_attrs_table">
        <caption>Attributes</caption>
      </table>

      <!-- camera actions and measure tool -->
      <div id="orbitbtn" class="action-btn action-orbit">Orbit</div>
      <div id="measurebtn" class="action-btn">Measure distance</div>
    </div>

    <!-- page info -->
    <div id="pageinfo">
      <h1>Current View URL</h1>
      <div><input id="urlbox" type="text"></div>

      <h1>Usage</h1>
      <table id="usage">
        <tr><td colspan="2" class="star">Mouse</td></tr>
        <tr><td>Left button + Move</td><td>Orbit</td></tr>
        <tr><td>Mouse Wheel</td><td>Zoom</td></tr>
        <tr><td>Right button + Move</td><td>Pan</td></tr>

        <tr><td colspan="2" class="star">Keys</td></tr>
        <tr><td>Arrow keys</td><td>Move Horizontally</td></tr>
        <tr><td>Shift + Arrow keys</td><td>Orbit</td></tr>
        <tr><td>Ctrl + Arrow keys</td><td>Rotate</td></tr>
        <tr><td>Shift + Ctrl + Up / Down</td><td>Zoom In / Out</td></tr>
        <tr><td>L</td><td>Toggle Label Visibility</td></tr>
        <tr><td>R</td><td>Start / Stop Orbit Animation</td></tr>
        <tr><td>W</td><td>Wireframe Mode</td></tr>
        <tr><td>Shift + R</td><td>Reset Camera Position</td></tr>
        <tr><td>Shift + S</td><td>Save Image</td></tr>
      </table>

      <h1>About</h1>
      <div id="about"><img src="./Qgis2threejs.png">
        This page was made with <a href="https://www.qgis.org/">QGIS</a> and <a href="https://github.com/minorua/Qgis2threejs">Qgis2threejs</a> plugin (version 2.8).
        <div>Powered by <a href="https://threejs.org/">three.js</a>
        <span id="lib_proj4js"> and <a href="https://trac.osgeo.org/proj4js/">Proj4js</a></span>.</div>
      </div>
    </div>
  </div>
</div>

<!-- progress bar -->
<div id="progress"><div id="progressbar"></div></div>

<!-- menu -->
<div id="toolbtns">
  <div id="layerbtn"></div>
  <div id="animbtn" class="hidden"></div>
  <div id="infobtn"></div>
</div>

<!-- header and footer -->
<div id="header"></div>
<div id="footer"></div>

<!-- layer panel -->
<div id="layerpanel">
  <div id="layerlist"></div>
</div>

<!-- animation -->
<div id="narrativebox" class="ef1">
  <div id="narbody">

  </div>
  <div id="nextbtn"></div>
</div>

<script>
Q3D.Config.allVisible = true;
Q3D.Config.bgColor = 0xffffff;
Q3D.Config.viewpoint = {lookAt:{x:426248.434989865,y:4517666.811603576,z:-1.1839921050606837e-15},pos:{x:432420.6401290015,y:4504911.042410877,z:3937.8688261482375}};
Q3D.Config.localMode = true;

var container = document.getElementById("view"),
    app = Q3D.application,
    gui = Q3D.gui;

app.init(container);       // initialize viewer
  

<!-- ------------------ Inizio modifica: loadSceneFile + hook parallelepipedo ------------------ -->
<script>
// Inserire questo script ESATTAMENTE dove c'era la chiamata app.loadSceneFile
// Questo hook chiama la funzione addParallelepipedToViewer() quando la scena è pronta.

(function(){

  // stile etichette (se non presente già)
  (function ensureLabelStyle(){
    if (!document.getElementById('label2d-style')) {
      const s = document.createElement('style');
      s.id = 'label2d-style';
      s.textContent = `
      .label2d {
        padding:2px 6px;
        background:rgba(255,255,255,0.95);
        border:1px solid #000;
        color:#000;
        font-weight:700;
        font-size:12px;
        border-radius:3px;
        white-space:nowrap;
        pointer-events:none;
        position:absolute;
        transform:translate(-50%,-50%);
        will-change:transform;
      }`;
      document.head.appendChild(s);
    }
  })();

  // funzione per aggiungere parallelepipedo + etichette
  function addParallelepipedToViewer(sceneObj) {
    try {
      const THREE = window.THREE;
      // preferisci usare app.scene se disponibile
      const scene = sceneObj || (window.app && app.scene) || window.scene;
      const camera = (window.app && app.camera) || window.camera || (window.viewer && viewer.camera);
      const renderer = (window.app && app.renderer) || window.renderer || (window.viewer && viewer.renderer);
      if (!THREE || !scene || !camera || !renderer) {
        console.error('Componente mancante: THREE/scene/camera/renderer', {THREE, scene, camera, renderer});
        return;
      }

      const DEPTH = 10000;
      const LABEL_STEP = 1000;
      const LABEL_OFFSET_PX = 30;

      // trova la DTM: byName -> contains 'dtm' -> fallback largest mesh
      function findDTM(scene){
        if (scene.getObjectByName) {
          const byName = scene.getObjectByName('DTM');
          if (byName) return byName;
        }
        let found = null;
        scene.traverse(o => {
          if (!found && o.isMesh && o.name && typeof o.name === 'string' && o.name.toLowerCase().includes('dtm')) found = o;
        });
        if (found) return found;
        let maxArea = -Infinity, best = null;
        scene.traverse(o => {
          if (o.isMesh) {
            const bb = new THREE.Box3().setFromObject(o);
            const s = new THREE.Vector3(); bb.getSize(s);
            const arr = [s.x,s.y,s.z].sort((a,b)=>b-a);
            const area = arr[0]*arr[1];
            if (area > maxArea) { maxArea = area; best = o; }
          }
        });
        return best;
      }

      const dtm = findDTM(scene);
      if (!dtm) { console.warn('DTM non trovato: nessun parallelepipedo aggiunto.'); return; }

      // rendi DTM sempre visibile (semi-trasparente)
      dtm.traverse(n => {
        if (n.isMesh) {
          const mats = Array.isArray(n.material) ? n.material : [n.material];
          for (const m of mats) {
            if (!m) continue;
            if (typeof m.opacity !== 'number' || m.opacity === 1) m.opacity = 0.6;
            m.transparent = true;
            m.depthTest = false;
            m.depthWrite = false;
            m.side = THREE.DoubleSide;
            m.needsUpdate = true;
          }
          n.renderOrder = 999;
        }
      });

      // bbox DTM (world coords)
      const bb = new THREE.Box3().setFromObject(dtm);

      // determina asse verticale: pick smallest dimension of scene bbox
      const totalBbox = new THREE.Box3().setFromObject(scene);
      const totalSize = new THREE.Vector3(); totalBbox.getSize(totalSize);
      let vertIndex = 1;
      if (totalSize.x <= totalSize.y && totalSize.x <= totalSize.z) vertIndex = 0;
      else if (totalSize.z <= totalSize.x && totalSize.z <= totalSize.y) vertIndex = 2;
      const axes2 = [0,1,2].filter(i=>i!==vertIndex);

      // punto 2D basso-destra = (max su axes2[0], min su axes2[1])
      const maxA = bb.max.getComponent(axes2[0]);
      const minB = bb.min.getComponent(axes2[1]);

      // superficie Z (top) prendiamo bb.max sul vertIndex
      const topZ = bb.max.getComponent(vertIndex);
      const bottomZ = topZ - DEPTH;

      // costruisci i 4 top corners (ordine: 0=basso-destra,1=alto-destra,2=alto-sin,3=basso-sin)
      const topCorners = [];
      topCorners.push(new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], minB).setComponent(vertIndex, topZ));
      topCorners.push(new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], bb.max.getComponent(axes2[1])).setComponent(vertIndex, topZ));
      topCorners.push(new THREE.Vector3().setComponent(axes2[0], bb.min.getComponent(axes2[0])).setComponent(axes2[1], bb.max.getComponent(axes2[1])).setComponent(vertIndex, topZ));
      topCorners.push(new THREE.Vector3().setComponent(axes2[0], bb.min.getComponent(axes2[0])).setComponent(axes2[1], minB).setComponent(vertIndex, topZ));
      const bottomCorners = topCorners.map(c => c.clone().setComponent(vertIndex, bottomZ));

      // disegna contorni: top rect, bottom rect, 4 verticali
      const matLine = new THREE.LineBasicMaterial({ color: 0x000000 });
      function addLine(p1,p2){ const geom = new THREE.BufferGeometry().setFromPoints([p1.clone(), p2.clone()]); const l = new THREE.Line(geom, matLine); scene.add(l); return l; }
      addLine(topCorners[0], topCorners[1]); addLine(topCorners[1], topCorners[2]);
      addLine(topCorners[2], topCorners[3]); addLine(topCorners[3], topCorners[0]);
      addLine(bottomCorners[0], bottomCorners[1]); addLine(bottomCorners[1], bottomCorners[2]);
      addLine(bottomCorners[2], bottomCorners[3]); addLine(bottomCorners[3], bottomCorners[0]);
      for (let i=0;i<4;i++) addLine(topCorners[i], bottomCorners[i]);

      // etichette solo sulla colonna in basso-destra (topCorners[0] -> bottomCorners[0])
      const labels = [];
      const cornerTop = topCorners[0].clone();
      const centerFoot = new THREE.Vector3();
      centerFoot.setComponent(axes2[0], (bb.max.getComponent(axes2[0]) + bb.min.getComponent(axes2[0]))/2 );
      centerFoot.setComponent(axes2[1], (bb.max.getComponent(axes2[1]) + bb.min.getComponent(axes2[1]))/2 );
      centerFoot.setComponent(vertIndex, 0);
      const dirOut = cornerTop.clone().setComponent(vertIndex,0).sub(centerFoot.clone().setComponent(vertIndex,0));
      if (dirOut.lengthSq() < 1e-6) { dirOut.setComponent(axes2[0],1); dirOut.setComponent(axes2[1],0); }
      dirOut.setComponent(vertIndex,0); dirOut.normalize();

      const footprintSize = Math.max( bb.getSize(new THREE.Vector3()).x, bb.getSize(new THREE.Vector3()).y );
      const labelOffset = LABEL_OFFSET_PX * 0.01 * footprintSize;

      for (let d = LABEL_STEP; d <= DEPTH; d += LABEL_STEP){
        const z = topZ - d;
        const pos = cornerTop.clone().setComponent(vertIndex, z);
        const posOut = pos.clone().add(dirOut.clone().multiplyScalar(labelOffset));
        const div = document.createElement('div');
        div.className = 'label2d';
        div.textContent = `-${d} m`;
        document.body.appendChild(div);
        labels.push({el: div, pos: posOut.clone()});
      }

      // aggiorna labels ogni frame
      function updateLabels() {
        for (const L of labels){
          const p = L.pos.clone().project(camera);
          if (p.z < -1 || p.z > 1) { L.el.style.display = 'none'; continue; }
          const screenX = (p.x + 1) * 0.5 * renderer.domElement.clientWidth;
          const screenY = (1 - p.y) * 0.5 * renderer.domElement.clientHeight;
          L.el.style.display = '';
          L.el.style.left = Math.round(screenX) + 'px';
          L.el.style.top  = Math.round(screenY) + 'px';
        }
      }

      // small RAF loop for labels (won't clash with app renderer)
      (function loop(){ requestAnimationFrame(loop); try{ updateLabels(); }catch(e){} })();

      console.log('Parallelepipedo aggiunto: top=',topZ,' bottom=',bottomZ,' cornerXY=',maxA,minB);
    } catch(err) {
      console.error('Errore in addParallelepipedToViewer:', err);
    }
  }

  // Ora facciamo partire la caricamento scena ma colleghiamo il callback "all files loaded"
  app.loadSceneFile("./data/index/scene.js",
    function(scene) { // scene file loaded
      app.start();
    },
    function(scene) { // all relevant files have been loaded -> qui la scena è pronta
      // scene parametro può essere usato (ma app.scene è già pronto)
      try {
        addParallelepipedToViewer(scene || app.scene);
      } catch(e) {
        console.error('Errore nel callback post-load:', e);
      }
    }
  );

})();
</script>
<!-- ------------------ Fine modifica ------------------ -->


});
</script>
</body>
</html>
