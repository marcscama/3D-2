<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>terremoti-07-2025</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<base target="_blank">
<link rel="stylesheet" type="text/css" href="./Qgis2threejs.css">
<style type="text/css">
#popup, #header, #layerpanel {
  left: 36px;
}
/* Stile per etichette DOM (CSS) - come volevi */
.label2d {
  padding:6px 8px;
  background:rgba(255,255,255,0.95);
  border:1px solid rgba(0,0,0,0.9);
  color:#000;
  font-weight:700;
  font-size:11px;         /* carattere un po' più piccolo */
  border-radius:4px;
  white-space:nowrap;
  pointer-events:none;    /* non interferiscono con mouse */
  position:absolute;
  transform:translate(-50%,-50%);
  z-index: 10;            /* rimangono sopra altri elementi DOM */
  transition: opacity 0.12s linear;
  will-change: transform, opacity;
}
</style>
<script src="./threejs/three.min.js"></script>
<script src="./threejs/OrbitControls.js"></script>
<script src="./threejs/ViewHelper.js"></script>
<script src="./threejs/OutlineEffect.js"></script>
<script src="./Qgis2threejs.js"></script>
</head>
<body>
<div id="view">
  <div id="northarrow"></div>
  <div id="navigation"></div>
</div>
<!-- popup -->
<div id="popup">
  <div id="closebtn">&times;</div>
  <div id="popupbar"></div>
  <div id="popupbody">
    <div id="popupcontent"></div>
    <!-- query result -->
    <div id="queryresult">
      <table id="qr_coords_table">
        <caption>Clicked coordinates <div id="zoomtopoint" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_coords"></td></tr>
      </table>
      <table id="qr_layername_table">
        <caption>Layer <div id="zoomtolayer" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_layername"></td></tr>
      </table>
      <table id="qr_attrs_table">
        <caption>Attributes</caption>
      </table>
      <!-- camera actions and measure tool -->
      <div id="orbitbtn" class="action-btn action-orbit">Orbit</div>
      <div id="measurebtn" class="action-btn">Measure distance</div>
    </div>
    <!-- page info -->
    <div id="pageinfo">
      <h1>Current View URL</h1>
      <div><input id="urlbox" type="text"></div>
      <h1>Usage</h1>
      <table id="usage">
        <tr><td colspan="2" class="star">Mouse</td></tr>
        <tr><td>Left button + Move</td><td>Orbit</td></tr>
        <tr><td>Mouse Wheel</td><td>Zoom</td></tr>
        <tr><td>Right button + Move</td><td>Pan</td></tr>
        <tr><td colspan="2" class="star">Keys</td></tr>
        <tr><td>Arrow keys</td><td>Move Horizontally</td></tr>
        <tr><td>Shift + Arrow keys</td><td>Orbit</td></tr>
        <tr><td>Ctrl + Arrow keys</td><td>Rotate</td></tr>
        <tr><td>Shift + Ctrl + Up / Down</td><td>Zoom In / Out</td></tr>
        <tr><td>L</td><td>Toggle Label Visibility</td></tr>
        <tr><td>R</td><td>Start / Stop Orbit Animation</td></tr>
        <tr><td>W</td><td>Wireframe Mode</td></tr>
        <tr><td>Shift + R</td><td>Reset Camera Position</td></tr>
        <tr><td>Shift + S</td><td>Save Image</td></tr>
      </table>
      <h1>About</h1>
      <div id="about"><img src="./Qgis2threejs.png">
        This page was made with <a href="https://www.qgis.org/">QGIS</a> and <a href="https://github.com/minorua/Qgis2threejs">Qgis2threejs</a> plugin (version 2.8).
        <div>Powered by <a href="https://threejs.org/">three.js</a>
        <span id="lib_proj4js"> and <a href="https://trac.osgeo.org/proj4js/">Proj4js</a></span>.</div>
      </div>
    </div>
  </div>
</div>
<!-- progress bar -->
<div id="progress"><div id="progressbar"></div></div>
<!-- menu -->
<div id="toolbtns">
  <div id="layerbtn"></div>
  <div id="animbtn" class="hidden"></div>
  <div id="infobtn"></div>
</div>
<!-- header and footer -->
<div id="header"></div>
<div id="footer"></div>
<!-- layer panel -->
<div id="layerpanel">
  <div id="layerlist"></div>
</div>
<!-- animation -->
<div id="narrativebox" class="ef1">
  <div id="narbody">
  </div>
  <div id="nextbtn"></div>
</div>
<script>
// Configurazione iniziale (mantengo quanto già funzionante)
Q3D.Config.allVisible = true;
Q3D.Config.bgColor = 0xffffff;
Q3D.Config.viewpoint = {
  lookAt: {x: 426248.434989865, y: 4517666.811603576, z: -1.1839921050606837e-15},
  pos: {x: 432420.6401290015, y: 4504911.042410877, z: 3937.8688261482375}
};
Q3D.Config.localMode = true;

var container = document.getElementById("view"),
    app = Q3D.application,
    gui = Q3D.gui;

console.log('Inizializzazione dell\'applicazione...');
try {
  app.init(container);       // initialize viewer
  console.log('Applicazione inizializzata correttamente.');
} catch (error) {
  console.error('Errore durante l\'inizializzazione dell\'applicazione:', error);
}

console.log('Caricamento del file della scena...');
try {
  app.loadSceneFile("./data/index/scene.js",
    function(scene) {
      console.log('File della scena caricato:', scene);
      try {
        app.start();
        console.log('Applicazione avviata.');
      } catch (error) {
        console.error('Errore durante l\'avvio dell\'applicazione:', error);
      }
    },
    function(scene) {
      console.log('Tutti i file rilevanti sono stati caricati:', scene);
      try {
        const THREE = window.THREE;
        const threeScene = (scene && scene.isScene) ? scene : (app && app.scene) || window.scene;
        const camera = (app && app.camera) || window.camera || (window.viewer && viewer.camera);
        const renderer = (app && app.renderer) || window.renderer || (window.viewer && viewer.renderer);

        console.log('Callback all files loaded - scene, camera, renderer:', !!threeScene, !!camera, !!renderer);
        if (!THREE || !threeScene || !camera || !renderer) {
          console.warn('Ambiente rendering non disponibile nel callback (THREE/scene/camera/renderer).');
          return;
        }

        // Cerca il layer DTM usando il layerId: 2
        let dtm = null;
        threeScene.traverse(function(object) {
          if (object.userData && object.userData.layerId === 2) {
            dtm = object;
            console.log('Layer DTM trovato con layerId: 2', object.name || 'no name');
          }
        });

        if (!dtm) {
          console.error('Impossibile trovare il layer DTM con layerId: 2');
          return;
        }

        // Rendi il DTM sempre visibile (mantengo le tue impostazioni)
        dtm.traverse(n => {
          if (n.isMesh) {
            const mats = Array.isArray(n.material) ? n.material : [n.material];
            for (const m of mats) {
              if (!m) continue;
              if (typeof m.opacity !== 'number' || m.opacity === 1) m.opacity = 0.6;
              m.transparent = true;
              m.depthTest = false;
              m.depthWrite = false;
              m.side = THREE.DoubleSide;
              m.needsUpdate = true;
            }
            n.renderOrder = 100;
          }
        });

        // Trova il layer dei terremoti (layerId: 0)
        let earthquakesLayer = null;
        threeScene.traverse(function(object) {
          if (object.userData && object.userData.layerId === 0) {
            earthquakesLayer = object;
            console.log('Layer terremoti trovato con layerId: 0', object.name || 'no name');
          }
        });

        // Se troviamo il layer dei terremoti, impostiamo un renderOrder alto per le sfere
        if (earthquakesLayer) {
          earthquakesLayer.traverse(n => {
            if (n.isMesh) {
              n.renderOrder = 2000;
            }
          });
        }

        // Bounding box e calcoli assi come prima
        const bb = new THREE.Box3().setFromObject(dtm);
        const size = bb.getSize(new THREE.Vector3());
        let vertIndex = 2;
        const minDimIndex = (size.x < size.y) ?
                          ((size.x < size.z) ? 0 : 2) :
                          ((size.y < size.z) ? 1 : 2);
        vertIndex = minDimIndex;
        const axes2 = [0,1,2].filter(i => i !== vertIndex);
        const minA = bb.min.getComponent(axes2[0]);
        const maxA = bb.max.getComponent(axes2[0]);
        const minB = bb.min.getComponent(axes2[1]);
        const maxB = bb.max.getComponent(axes2[1]);

        // Parametri del parallelepipedo e etichette
        const DEPTH = 10000;
        const STEP = 1000;
        const LABEL_OFFSET = 30;
        const referenceZ = 0;
        const topZParallelepiped = referenceZ;
        const bottomZParallelepiped = referenceZ - DEPTH;

        const topCorners = [
          new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], minB).setComponent(vertIndex, topZParallelepiped),
          new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], maxB).setComponent(vertIndex, topZParallelepiped),
          new THREE.Vector3().setComponent(axes2[0], minA).setComponent(axes2[1], maxB).setComponent(vertIndex, topZParallelepiped),
          new THREE.Vector3().setComponent(axes2[0], minA).setComponent(axes2[1], minB).setComponent(vertIndex, topZParallelepiped)
        ];
        const bottomCorners = topCorners.map(c => c.clone().setComponent(vertIndex, bottomZParallelepiped));

        // Linee del parallelepipedo (come prima)
        const matLine = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2, opacity: 0.8, transparent: true });
        function addLine(p1,p2){ const geom=new THREE.BufferGeometry().setFromPoints([p1.clone(), p2.clone()]); const l=new THREE.Line(geom, matLine); threeScene.add(l); return l; }
        for(let i=0;i<4;i++){ addLine(topCorners[i], topCorners[(i+1)%4]); }
        for(let i=0;i<4;i++){ addLine(bottomCorners[i], bottomCorners[(i+1)%4]); }
        for(let i=0;i<4;i++){ addLine(topCorners[i], bottomCorners[i]); }

        // Punto centrale per calcolo direzione etichette
        const centerFoot = new THREE.Vector3();
        centerFoot.setComponent(axes2[0], (maxA + minA) / 2);
        centerFoot.setComponent(axes2[1], (maxB + minB) / 2);
        centerFoot.setComponent(vertIndex, 0);
        const cornerTop = topCorners[0].clone();
        const dirOut = cornerTop.clone().setComponent(vertIndex, 0).sub(centerFoot.clone().setComponent(vertIndex, 0));
        if (dirOut.lengthSq() < 1e-6){ dirOut.setComponent(axes2[0], 1); dirOut.setComponent(axes2[1], 0); }
        dirOut.setComponent(vertIndex, 0);
        dirOut.normalize();

        // --- NUOVA LOGICA: etichette DOM + occlusione approssimata dalle sfere ---
        const labels = [];       // { el: DOMElement, pos: THREE.Vector3 }
        const sphereMeshes = []; // lista di mesh sfera per controllare l'occlusione

        // Raccogli le mesh sfera (assumendo che i terremoti siano mesh sotto earthquakesLayer)
        if (earthquakesLayer) {
          earthquakesLayer.traverse(function(n) {
            if (n.isMesh) {
              sphereMeshes.push(n);
            }
          });
        }

        // Crea le etichette DOM per -1000, -2000, ... e 0 m
        function createLabel(text, worldPos) {
          const div = document.createElement('div');
          div.className = 'label2d';
          div.textContent = text;
          div.style.opacity = '1';
          document.body.appendChild(div);
          labels.push({ el: div, pos: worldPos.clone() });
        }

        for (let d = 1000; d <= DEPTH; d += STEP) {
          const z = topZParallelepiped - d;
          const pos = cornerTop.clone().setComponent(vertIndex, z).add(dirOut.clone().multiplyScalar(LABEL_OFFSET));
          createLabel(`-${d} m`, pos);
        }
        // 0 m
        {
          const z = topZParallelepiped;
          const pos = cornerTop.clone().setComponent(vertIndex, z).add(dirOut.clone().multiplyScalar(LABEL_OFFSET));
          createLabel(`0 m`, pos);
        }

        // Parametri per la logica di occlusione DOM
        const OCCLUSION_PIXEL_THRESHOLD = 20; // soglia in pixel per considerare che una sfera "copre" l'etichetta
        // puoi abbassare a 12 o aumentare a 40 a seconda della dimensione delle sfere nell'app

        // Funzione di aggiornamento delle etichette (posizione e occlusione)
        const tmpVec = new THREE.Vector3();
        const proj = new THREE.Vector3();
        function updateLabels() {
          const widthHalf = container.clientWidth / 2;
          const heightHalf = container.clientHeight / 2;
          // Pre-proiettiamo tutte le sfere (posizioni e depth) per velocizzare
          const projectedSpheres = [];
          for (const mesh of sphereMeshes) {
            // posizione mondo della sfera (centro)
            mesh.getWorldPosition(tmpVec);
            proj.copy(tmpVec).project(camera);
            // converti a pixel
            const sx = (proj.x * widthHalf) + widthHalf;
            const sy = -(proj.y * heightHalf) + heightHalf;
            projectedSpheres.push({
              mesh: mesh,
              ndcZ: proj.z,
              sx: sx,
              sy: sy
            });
          }

          // ora aggiorniamo ogni etichetta
          for (const label of labels) {
            // proietta posizione etichetta
            const v = label.pos.clone().project(camera);
            // se dietro la telecamera, nascondi
            if (v.z < -1 || v.z > 1) {
              label.el.style.display = 'none';
              continue;
            }
            const lx = (v.x * widthHalf) + widthHalf;
            const ly = -(v.y * heightHalf) + heightHalf;

            // Posiziona l'elemento DOM (centrato)
            label.el.style.display = '';
            label.el.style.left = `${Math.round(lx)}px`;
            label.el.style.top = `${Math.round(ly)}px`;

            // Controllo di occlusione: se esiste almeno una sfera proiettata "vicina" e con ndcZ < label.ndcZ allora la sfera è davanti -> nascondi etichetta
            let occluded = false;
            const labelNDCz = v.z;
            for (let i = 0; i < projectedSpheres.length; i++) {
              const ps = projectedSpheres[i];
              // se la sfera è fuori dallo schermo possiamo saltarla
              if (ps.sx < -100 || ps.sx > container.clientWidth + 100 || ps.sy < -100 || ps.sy > container.clientHeight + 100) continue;
              // distanza in pixel tra proiezioni
              const dx = ps.sx - lx;
              const dy = ps.sy - ly;
              const distPx = Math.sqrt(dx*dx + dy*dy);
              // se la sfera è abbastanza vicina nello schermo e si trova "davanti" (ndc z minore)
              if (distPx <= OCCLUSION_PIXEL_THRESHOLD && ps.ndcZ < labelNDCz) {
                occluded = true;
                break;
              }
            }

            // Applichiamo nascondi o mostra con transizione
            if (occluded) {
              // opzione: nascondo completamente
              label.el.style.opacity = '0';
              // oppure per debug: label.el.style.opacity = '0.35';
            } else {
              label.el.style.opacity = '1';
            }
          }

          requestAnimationFrame(updateLabels);
        }

        // Avvia loop etichette
        updateLabels();

        console.log('Parallelepipedo e etichette DOM aggiunti (con occlusione approssimata).');

      } catch (err) {
        console.error('Errore nel callback parallelepipedo:', err);
      }
    }
  );
} catch (error) {
  console.error('Errore durante il caricamento del file della scena:', error);
}
</script>
</body>
</html>
