<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>terremoti-07-2025</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<base target="_blank">
<link rel="stylesheet" type="text/css" href="./Qgis2threejs.css">
<style type="text/css">
#popup, #header, #layerpanel {
  left: 36px;
}
</style>
<script src="./threejs/three.min.js"></script>
<script src="./threejs/OrbitControls.js"></script>
<script src="./threejs/ViewHelper.js"></script>
<script src="./threejs/OutlineEffect.js"></script>
<script src="./Qgis2threejs.js"></script>
</head>  
<body>
<div id="view">
  <div id="northarrow"></div>
  <div id="navigation"></div>
</div>

<!-- popup -->
<div id="popup">
  <div id="closebtn">&times;</div>
  <div id="popupbar"></div>
  <div id="popupbody">
    <div id="popupcontent"></div>

    <!-- query result -->
    <div id="queryresult">
      <table id="qr_coords_table">
        <caption>Clicked coordinates <div id="zoomtopoint" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_coords"></td></tr>
      </table>

      <table id="qr_layername_table">
        <caption>Layer <div id="zoomtolayer" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_layername"></td></tr>
      </table>

      <table id="qr_attrs_table">
        <caption>Attributes</caption>
      </table>

      <!-- camera actions and measure tool -->
      <div id="orbitbtn" class="action-btn action-orbit">Orbit</div>
      <div id="measurebtn" class="action-btn">Measure distance</div>
    </div>

    <!-- page info -->
    <div id="pageinfo">
      <h1>Current View URL</h1>
      <div><input id="urlbox" type="text"></div>

      <h1>Usage</h1>
      <table id="usage">
        <tr><td colspan="2" class="star">Mouse</td></tr>
        <tr><td>Left button + Move</td><td>Orbit</td></tr>
        <tr><td>Mouse Wheel</td><td>Zoom</td></tr>
        <tr><td>Right button + Move</td><td>Pan</td></tr>

        <tr><td colspan="2" class="star">Keys</td></tr>
        <tr><td>Arrow keys</td><td>Move Horizontally</td></tr>
        <tr><td>Shift + Arrow keys</td><td>Orbit</td></tr>
        <tr><td>Ctrl + Arrow keys</td><td>Rotate</td></tr>
        <tr><td>Shift + Ctrl + Up / Down</td><td>Zoom In / Out</td></tr>
        <tr><td>L</td><td>Toggle Label Visibility</td></tr>
        <tr><td>R</td><td>Start / Stop Orbit Animation</td></tr>
        <tr><td>W</td><td>Wireframe Mode</td></tr>
        <tr><td>Shift + R</td><td>Reset Camera Position</td></tr>
        <tr><td>Shift + S</td><td>Save Image</td></tr>
      </table>

      <h1>About</h1>
      <div id="about"><img src="./Qgis2threejs.png">
        This page was made with <a href="https://www.qgis.org/">QGIS</a> and <a href="https://github.com/minorua/Qgis2threejs">Qgis2threejs</a> plugin (version 2.8).
        <div>Powered by <a href="https://threejs.org/">three.js</a>
        <span id="lib_proj4js"> and <a href="https://trac.osgeo.org/proj4js/">Proj4js</a></span>.</div>
      </div>
    </div>
  </div>
</div>

<!-- progress bar -->
<div id="progress"><div id="progressbar"></div></div>

<!-- menu -->
<div id="toolbtns">
  <div id="layerbtn"></div>
  <div id="animbtn" class="hidden"></div>
  <div id="infobtn"></div>
</div>

<!-- header and footer -->
<div id="header"></div>
<div id="footer"></div>

<!-- layer panel -->
<div id="layerpanel">
  <div id="layerlist"></div>
</div>

<!-- animation -->
<div id="narrativebox" class="ef1">
  <div id="narbody">

  </div>
  <div id="nextbtn"></div>
</div>

<script>
Q3D.Config.allVisible = true;
Q3D.Config.bgColor = 0xffffff;
Q3D.Config.viewpoint = {lookAt:{x:426248.434989865,y:4517666.811603576,z:-1.1839921050606837e-15},pos:{x:432420.6401290015,y:4504911.042410877,z:3937.8688261482375}};
Q3D.Config.localMode = true;

var container = document.getElementById("view"),
    app = Q3D.application,
    gui = Q3D.gui;

app.init(container);       // initialize viewer

// load the scene
app.loadSceneFile("./data/index/scene.js", function (scene) {
  // scene file has been loaded
  app.start();
}, function (scene) {
  // all relevant files have been loaded

});
</script>
  <!-- === Aggiunta parallelepipedo & etichette (incolla prima di </body>) === -->
<style>
/* Manteniamo lo stile delle etichette uguale a quanto usato prima */
.label2d {
  padding:2px 6px;
  background:rgba(255,255,255,0.95);
  border:1px solid #000;
  color:#000;
  font-weight:700;
  font-size:12px;
  border-radius:3px;
  white-space:nowrap;
  pointer-events:none;
  position: absolute;
  transform: translate(-50%, -50%);
  will-change: transform;
}
</style>

<script>
(function(){
  // Config
  const DEPTH = 10000;      // scende di 10000 m dalla superficie
  const LABEL_STEP = 1000;  // etichette ogni 1000 m
  const LABEL_OFFSET_PX = 30;

  // Utility: proietta un punto 3D nello schermo (usa camera e renderer del viewer)
  function projectToScreen(pos3, camera, renderer) {
    const width = renderer.domElement.clientWidth;
    const height = renderer.domElement.clientHeight;
    const p = pos3.clone().project(camera);
    return {
      x: (p.x + 1) * 0.5 * width,
      y: (1 - p.y) * 0.5 * height,
      z: p.z
    };
  }

  function createLabelDOM(text, pos3) {
    const div = document.createElement('div');
    div.className = 'label2d';
    div.textContent = text;
    document.body.appendChild(div);
    return { el: div, pos: pos3.clone() };
  }

  // trova DTM nella scena: byName 'DTM', contiene 'dtm', oppure biggest footprint mesh
  function findDTM(scene, THREE) {
    if (scene.getObjectByName) {
      const byName = scene.getObjectByName('DTM');
      if (byName) return byName;
    }
    let found = null;
    scene.traverse(obj => {
      if (!found && obj.isMesh && obj.name && typeof obj.name === 'string' && obj.name.toLowerCase().includes('dtm')) found = obj;
    });
    if (found) return found;

    let maxArea = -Infinity, best = null;
    scene.traverse(obj => {
      if (obj.isMesh) {
        const bb = new THREE.Box3().setFromObject(obj);
        const s = new THREE.Vector3(); bb.getSize(s);
        const arr = [s.x, s.y, s.z].sort((a,b)=>b-a);
        const area = arr[0]*arr[1];
        if (area > maxArea) { maxArea = area; best = obj; }
      }
    });
    return best;
  }

  // attendi che app (Qgis2threejs) abbia inizializzato scene/camera/renderer
  function waitForApp(timeout = 8000) {
    return new Promise((resolve, reject) => {
      const start = Date.now();
      (function tick(){
        // la tua pagina definisce var container/app/gui; abbiamo "app" definito sopra nell'index.html
        if (window.app && (app.scene || app.viewer && app.viewer.scene || window.scene) && (app.camera || app.viewer && app.viewer.camera || window.camera) && (app.renderer || app.viewer && app.viewer.renderer || window.renderer)) {
          // preferenze: usa app.scene/app.camera/app.renderer se disponibili
          const scene = app.scene || (app.viewer && app.viewer.scene) || window.scene;
          const camera = app.camera || (app.viewer && app.viewer.camera) || window.camera;
          const renderer = app.renderer || (app.viewer && app.viewer.renderer) || window.renderer;
          return resolve({ THREE: window.THREE, scene: scene, camera: camera, renderer: renderer });
        }
        if (Date.now() - start > timeout) return reject(new Error('Viewer Qgis2threejs non trovato/inizializzato. Assicurati di incollare questo script DOPO gli script del viewer.'));
        requestAnimationFrame(tick);
      }());
    });
  }

  waitForApp().then(({THREE, scene, camera, renderer}) => {
    // Trova DTM
    const dtm = findDTM(scene, THREE);
    if (!dtm) {
      console.warn('DTM non trovato nella scena.');
      return;
    }

    // Rendi DTM sempre visibile (semi-trasparente) per evitare problemi di depth/invisibilitÃ 
    dtm.traverse(n => {
      if (n.isMesh) {
        const mats = Array.isArray(n.material) ? n.material : [n.material];
        for (const m of mats) {
          if (!m) continue;
          if (typeof m.opacity !== 'number' || m.opacity === 1) m.opacity = 0.6;
          m.transparent = true;
          m.depthTest = false;
          m.depthWrite = false;
          m.side = THREE.DoubleSide;
          m.needsUpdate = true;
        }
        n.renderOrder = 999;
      }
    });

    // bbox del DTM (in world coord)
    const bb = new THREE.Box3().setFromObject(dtm);

    // determina asse "verticale" come dimensione minore del bbox totale della scena
    const totalBbox = new THREE.Box3().setFromObject(scene);
    const totalSize = new THREE.Vector3(); totalBbox.getSize(totalSize);
    let vertIndex = 1; // default Y
    if (totalSize.x <= totalSize.y && totalSize.x <= totalSize.z) vertIndex = 0;
    else if (totalSize.z <= totalSize.x && totalSize.z <= totalSize.y) vertIndex = 2;
    const axes2 = [0,1,2].filter(i=>i!==vertIndex);

    // punto 2D "basso a destra" = (max su axes2[0], min su axes2[1])
    const maxA = bb.max.getComponent(axes2[0]);
    const minB = bb.min.getComponent(axes2[1]);

    // superficie Z (top) prendiamo bb.max sul vertIndex
    const topZ = bb.max.getComponent(vertIndex);
    const bottomZ = topZ - DEPTH;

    // costruisci i 4 top corners: (ordine: 0=basso-destra,1=alto-destra,2=alto-sin,3=basso-sin)
    const topCorners = [];
    topCorners.push(new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], minB).setComponent(vertIndex, topZ));
    topCorners.push(new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], bb.max.getComponent(axes2[1])).setComponent(vertIndex, topZ));
    topCorners.push(new THREE.Vector3().setComponent(axes2[0], bb.min.getComponent(axes2[0])).setComponent(axes2[1], bb.max.getComponent(axes2[1])).setComponent(vertIndex, topZ));
    topCorners.push(new THREE.Vector3().setComponent(axes2[0], bb.min.getComponent(axes2[0])).setComponent(axes2[1], minB).setComponent(vertIndex, topZ));

    const bottomCorners = topCorners.map(c => c.clone().setComponent(vertIndex, bottomZ));

    // disegna contorni generali (top rect, bottom rect, 4 verticali)
    const lineMat = new THREE.LineBasicMaterial({ color: 0x000000 });
    function addLine(p1,p2){
      const geom = new THREE.BufferGeometry().setFromPoints([p1.clone(), p2.clone()]);
      const line = new THREE.Line(geom, lineMat);
      scene.add(line);
      return line;
    }
    addLine(topCorners[0], topCorners[1]);
    addLine(topCorners[1], topCorners[2]);
    addLine(topCorners[2], topCorners[3]);
    addLine(topCorners[3], topCorners[0]);

    addLine(bottomCorners[0], bottomCorners[1]);
    addLine(bottomCorners[1], bottomCorners[2]);
    addLine(bottomCorners[2], bottomCorners[3]);
    addLine(bottomCorners[3], bottomCorners[0]);

    for (let i=0;i<4;i++) addLine(topCorners[i], bottomCorners[i]);

    // etichette SOLO sulla colonna in basso-destra (topCorners[0] -> bottomCorners[0])
    const labels = [];
    const cornerTop = topCorners[0].clone();

    // direzione outward nella footprint per offset (per leggere le label esternamente)
    const centerFoot = new THREE.Vector3();
    centerFoot.setComponent(axes2[0], (bb.max.getComponent(axes2[0]) + bb.min.getComponent(axes2[0]))/2 );
    centerFoot.setComponent(axes2[1], (bb.max.getComponent(axes2[1]) + bb.min.getComponent(axes2[1]))/2 );
    centerFoot.setComponent(vertIndex, 0);
    const dirOut = cornerTop.clone().setComponent(vertIndex,0).sub(centerFoot.clone().setComponent(vertIndex,0));
    if (dirOut.lengthSq() < 1e-6) { dirOut.setComponent(axes2[0],1); dirOut.setComponent(axes2[1],0); }
    dirOut.setComponent(vertIndex,0); dirOut.normalize();

    const footprintSize = Math.max( bb.getSize(new THREE.Vector3()).x, bb.getSize(new THREE.Vector3()).y );
    const labelOffset = LABEL_OFFSET_PX * 0.01 * footprintSize;

    for (let d = LABEL_STEP; d <= DEPTH; d += LABEL_STEP){
      const z = topZ - d;
      const pos = cornerTop.clone().setComponent(vertIndex, z);
      const posOut = pos.clone().add(dirOut.clone().multiplyScalar(labelOffset));
      labels.push(createLabelDOM(`-${d} m`, posOut));
    }

    // aggiorna etichette ogni frame
    function updateLabels(){
      for (const L of labels){
        const screen = projectToScreen(L.pos, camera, renderer);
        if (screen.z < -1 || screen.z > 1) { L.el.style.display = 'none'; }
        else {
          L.el.style.display = '';
          L.el.style.left = Math.round(screen.x) + 'px';
          L.el.style.top  = Math.round(screen.y) + 'px';
        }
      }
    }

    // avvia il loop di update (non interferisce con Qgis2threejs render loop)
    (function loop(){
      requestAnimationFrame(loop);
      try { updateLabels(); } catch(e) {}
    })();

    console.log('Parallelepipedo aggiunto (topZ=',topZ,', bottomZ=',bottomZ,') cornerXY=', maxA, minB);

  }).catch(err => {
    console.error(err);
    alert('Non sono riuscito a trovare il viewer (scene/camera/renderer). Assicurati di incollare questo script DOPO gli scripts generati da Qgis2threejs.');
  });

})();
</script>
<!-- === Fine blocco parallelepipedo & etichette === -->

</body>
</html>
