<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Terremoti nei Campi Flegrei dal 2005 al 07-2025, con MD>=2</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<base target="_blank">
<link rel="stylesheet" type="text/css" href="./Qgis2threejs.css">
<style type="text/css">
#popup, #header, #layerpanel {
  left: 36px;
}
.label2d {
  padding:2px 6px;
  background:rgba(255,255,255,0.95);
  border:1px solid #000;
  color:#000;
  font-weight:700;
  font-size:12px;
  border-radius:3px;
  white-space:nowrap;
  pointer-events:none;
  position:absolute;
  transform:translate(-50%,-50%);
}
/* UI panel moved to RIGHT (kept Qgis2threejs UI intact) */
#drawUI {
  position: absolute;
  top: 12px;
  right: 12px;
  left: auto;
  background: rgba(255,255,255,0.95);
  border-radius: 8px;
  padding: 10px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  z-index: 2000;
  font-family: sans-serif;
}
#drawUI h3 { margin:4px 0 8px 0; font-size:14px }
.ui-row { display:flex; align-items:center; gap:8px; margin:6px 0 }
button.tool { padding:6px 8px; border-radius:6px; border:1px solid #888; background:#f5f5f5; cursor:pointer }
button.tool.active { background:#0a84ff; color:#fff; border-color:#066fd6 }
input[type=color] { width:34px; height:28px; padding:0; border:none; }
input[type=range] { width:110px }
#pointer { position:fixed; pointer-events:none; z-index:3000; width:24px; height:24px; border-radius:50%; transform:translate(-50%,-50%); border:2px solid rgba(0,0,0,0.6); background: rgba(255,255,255,0.3) }
#pointer.eraser { background: rgba(255,255,255,0.1); border:2px dashed rgba(0,0,0,0.6) }
</style>

<!-- keep local non-module three for Qgis2threejs compatibility -->
<script src="./threejs/three.min.js"></script>
<script src="./threejs/OrbitControls.js"></script>
<script src="./threejs/ViewHelper.js"></script>
<script src="./threejs/OutlineEffect.js"></script>
<script src="./Qgis2threejs.js"></script>
<!-- optional local Line2 (fallback) -->
<script src="./threejs/lines/LineGeometry.js"></script>
<script src="./threejs/lines/LineMaterial.js"></script>
<script src="./threejs/lines/Line2.js"></script>
</head>
<body>
<div id="view">
  <div id="northarrow"></div>
  <div id="navigation"></div>
</div>
<!-- popup (restored full Qgis2threejs popup UI) -->
<div id="popup">
  <div id="closebtn">&times;</div>
  <div id="popupbar"></div>
  <div id="popupbody">
    <div id="popupcontent"></div>
    <!-- query result -->
    <div id="queryresult">
      <table id="qr_coords_table">
        <caption>Clicked coordinates <div id="zoomtopoint" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_coords"></td></tr>
      </table>
      <table id="qr_layername_table">
        <caption>Layer <div id="zoomtolayer" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_layername"></td></tr>
      </table>
      <table id="qr_attrs_table">
        <caption>Attributes</caption>
      </table>
      <!-- camera actions and measure tool -->
      <div id="orbitbtn" class="action-btn action-orbit">Orbit</div>
      <div id="measurebtn" class="action-btn">Measure distance</div>
    </div>
    <!-- page info -->
    <div id="pageinfo">
      <h1>Current View URL</h1>
      <div><input id="urlbox" type="text"></div>
      <h1>Usage</h1>
      <table id="usage">
        <tr><td colspan="2" class="star">Mouse</td></tr>
        <tr><td>Left button + Move</td><td>Orbit</td></tr>
        <tr><td>Mouse Wheel</td><td>Zoom</td></tr>
        <tr><td>Right button + Move</td><td>Pan</td></tr>
        <tr><td colspan="2" class="star">Keys</td></tr>
        <tr><td>Arrow keys</td><td>Move Horizontally</td></tr>
        <tr><td>Shift + Arrow keys</td><td>Orbit</td></tr>
        <tr><td>Ctrl + Arrow keys</td><td>Rotate</td></tr>
        <tr><td>Shift + Ctrl + Up / Down</td><td>Zoom In / Out</td></tr>
        <tr><td>L</td><td>Toggle Label Visibility</td></tr>
        <tr><td>R</td><td>Start / Stop Orbit Animation</td></tr>
        <tr><td>W</td><td>Wireframe Mode</td></tr>
        <tr><td>Shift + R</td><td>Reset Camera Position</td></tr>
        <tr><td>Shift + S</td><td>Save Image</td></tr>
      </table>
      <h1>About</h1>
      <div id="about"><img src="./Qgis2threejs.png">
        This page was made with <a href="https://www.qgis.org/">QGIS</a> and <a href="https://github.com/minorua/Qgis2threejs">Qgis2threejs</a> plugin (version 2.8).
        <div>Powered by <a href="https://threejs.org/">three.js</a>
        <span id="lib_proj4js"> and <a href="https://trac.osgeo.org/proj4js/">Proj4js</a></span>.</div>
      </div>
    </div>
  </div>
</div>

<!-- progress bar -->
<div id="progress"><div id="progressbar"></div></div>
<!-- menu -->
<div id="toolbtns">
  <div id="layerbtn"></div>
  <div id="animbtn" class="hidden"></div>
  <div id="infobtn"></div>
</div>
<!-- header and footer -->
<div id="header"></div>
<div id="footer"></div>
<!-- layer panel -->
<div id="layerpanel">
  <div id="layerlist"></div>
</div>
<!-- animation -->
<div id="narrativebox" class="ef1">
  <div id="narbody"></div>
  <div id="nextbtn"></div>
</div>

<!-- DRAW/ERASE UI -->
<div id="drawUI">
  <h3>Annota</h3>
  <div class="ui-row">
    <button id="penBtn" class="tool">‚úèÔ∏è Pen</button>
    <button id="eraserBtn" class="tool">üßΩ Eraser</button>
    <button id="clearBtn" class="tool">üóë Clear</button>
  </div>
  <div class="ui-row">
    <label>Color</label>
    <input id="colorPicker" type="color" value="#ff0000">
  </div>
  <div class="ui-row">
    <label>Thickness</label>
    <input id="thickness" type="range" min="1" max="20" value="4">
    <span id="thicknessVal">4</span>
  </div>
  <div class="ui-row">
    <label>Eraser size</label>
    <input id="eraserSize" type="range" min="8" max="80" value="32">
    <span id="eraserVal">32</span>
  </div>
  <div style="font-size:12px; margin-top:6px; color:#333">Hold left mouse to draw/erase. Pen & Eraser disable rotation; pan & zoom remain available.</div>
</div>

<div id="pointer"></div>

<script>
// ---- Config iniziale (uguale al codice base fornito) ----
Q3D.Config.allVisible = true;
Q3D.Config.bgColor = 0xffffff;
Q3D.Config.viewpoint = {
  lookAt: {x: 426248.434989865, y: 4517666.811603576, z: -1.1839921050606837e-15},
  pos: {x: 432420.6401290015, y: 4504911.042410877, z: 3937.8688261482375}
};
Q3D.Config.localMode = true;

var container = document.getElementById("view"),
    app = Q3D.application,
    gui = Q3D.gui;

console.log('Init app...');
try { app.init(container); } catch(e){ console.warn('app.init failed', e); }

// helper: async loader for Line2 modules so they're available before drawing
let line2ReadyResolve;
const line2Ready = new Promise((res)=>{ line2ReadyResolve = res; });
let hasLine2 = !!(THREE.Line2 && THREE.LineGeometry && THREE.LineMaterial);
(async ()=>{
  if (!hasLine2){
    try{
      const base = 'https://unpkg.com/three@0.165.0/examples/jsm/lines/';
      const modGeom = await import(base + 'LineGeometry.js');
      const modMat = await import(base + 'LineMaterial.js');
      const mod2 = await import(base + 'Line2.js');
      THREE.LineGeometry = modGeom.LineGeometry;
      THREE.LineMaterial = modMat.LineMaterial;
      THREE.Line2 = mod2.Line2;
      hasLine2 = true;
      console.log('Line2 modules imported');
    }catch(e){ console.warn('Line2 import failed, fallback to THREE.Line', e); hasLine2=false; }
  }
  line2ReadyResolve();
})();

app.loadSceneFile('./data/index/scene.js', function(scene){
  try { app.start(); } catch(e){ console.warn('app.start', e);} 
}, function(scene){
  try {
    const THREE = window.THREE;
    const threeScene = (scene && scene.isScene) ? scene : (app && app.scene) || window.scene;
    const camera = (app && app.camera) || window.camera || (window.viewer && viewer.camera);
    const renderer = (app && app.renderer) || window.renderer || (window.viewer && viewer.renderer);

    if (!THREE || !threeScene || !camera || !renderer) {
      console.error('Missing rendering context'); return;
    }

    // --- Parallelepipedo & etichette (integrazione completa) ---
    let dtm = null;
    threeScene.traverse(function(object){ if (object.userData && object.userData.layerId === 2) dtm = object; });
    if (!dtm) console.warn('DTM layer not found (layerId 2)');
    if (dtm) dtm.traverse(n => { if (n.isMesh) { const mats = Array.isArray(n.material)?n.material:[n.material]; for (const m of mats) { if (!m) continue; if (typeof m.opacity !== 'number' || m.opacity === 1) m.opacity = 0.6; m.transparent = true; m.depthTest=false; m.depthWrite=false; m.side=THREE.DoubleSide; m.needsUpdate=true; } n.renderOrder=999; } });

    const bb = new THREE.Box3().setFromObject(dtm || threeScene);
    const size = bb.getSize(new THREE.Vector3());
    const minDimIndex = (size.x < size.y) ? ((size.x < size.z) ? 0 : 2) : ((size.y < size.z) ? 1 : 2);
    const vertIndex = minDimIndex;
    const axes2 = [0,1,2].filter(i=>i!==vertIndex);
    const minA = bb.min.getComponent(axes2[0]); const maxA = bb.max.getComponent(axes2[0]);
    const minB = bb.min.getComponent(axes2[1]); const maxB = bb.max.getComponent(axes2[1]);

    const DEPTH = 10000; const STEP = 1000; const LABEL_OFFSET = 30; const referenceZ = 0;
    const topZParallelepiped = referenceZ; const bottomZParallelepiped = referenceZ - DEPTH;

    function makeVec(){ return new THREE.Vector3(); }
    const topCorners = [
      makeVec().setComponent(axes2[0], maxA).setComponent(axes2[1], minB).setComponent(vertIndex, topZParallelepiped),
      makeVec().setComponent(axes2[0], maxA).setComponent(axes2[1], maxB).setComponent(vertIndex, topZParallelepiped),
      makeVec().setComponent(axes2[0], minA).setComponent(axes2[1], maxB).setComponent(vertIndex, topZParallelepiped),
      makeVec().setComponent(axes2[0], minA).setComponent(axes2[1], minB).setComponent(vertIndex, topZParallelepiped)
    ];
    const bottomCorners = topCorners.map(c=>c.clone().setComponent(vertIndex, bottomZParallelepiped));

    const matLine = new THREE.LineBasicMaterial({ color:0x000000, linewidth:2, opacity:0.8, transparent:true });
    function addLine(p1,p2){ const geom = new THREE.BufferGeometry().setFromPoints([p1.clone(), p2.clone()]); const l = new THREE.Line(geom, matLine); threeScene.add(l); return l; }

    for (let i=0;i<4;i++) addLine(topCorners[i], topCorners[(i+1)%4]);
    for (let i=0;i<4;i++) addLine(bottomCorners[i], bottomCorners[(i+1)%4]);
    for (let i=0;i<4;i++) addLine(topCorners[i], bottomCorners[i]);

    if (!document.getElementById('label2d-style')){
      const s = document.createElement('style'); s.id='label2d-style'; s.textContent = `.label2d{padding:2px 6px;background:rgba(255,255,255,0.95);border:1px solid #000;color:#000;font-weight:700;font-size:12px;border-radius:3px;white-space:nowrap;pointer-events:none;position:absolute;transform:translate(-50%,-50%);}`; document.head.appendChild(s);
    }
    const labels=[];
    const centerFoot = makeVec(); centerFoot.setComponent(axes2[0], (maxA+minA)/2); centerFoot.setComponent(axes2[1], (maxB+minB)/2); centerFoot.setComponent(vertIndex, 0);
    const cornerTop = topCorners[0].clone();
    const dirOut = cornerTop.clone().setComponent(vertIndex,0).sub(centerFoot.clone().setComponent(vertIndex,0)); if (dirOut.lengthSq()<1e-6){ dirOut.setComponent(axes2[0],1); dirOut.setComponent(axes2[1],0); } dirOut.setComponent(vertIndex,0); dirOut.normalize();
    for (let d=1000; d<=DEPTH; d+=STEP){ const z = topZParallelepiped - d; const pos = cornerTop.clone().setComponent(vertIndex,z).add(dirOut.clone().multiplyScalar(LABEL_OFFSET)); const div = document.createElement('div'); div.className='label2d'; div.textContent=`-${d} m`; div.style.zIndex='1000'; document.body.appendChild(div); labels.push({el:div,pos:pos.clone()}); }
    { const z = topZParallelepiped; const pos = cornerTop.clone().setComponent(vertIndex,z).add(dirOut.clone().multiplyScalar(LABEL_OFFSET)); const div=document.createElement('div'); div.className='label2d'; div.textContent='0 m'; div.style.zIndex='1000'; document.body.appendChild(div); labels.push({el:div,pos:pos.clone()}); }

    function updateLabels(){ requestAnimationFrame(updateLabels); try{ for (const L of labels){ const p=L.pos.clone().project(camera); if (p.z<-1||p.z>1){ L.el.style.display='none'; continue; } const sx=(p.x+1)*0.5*renderer.domElement.clientWidth; const sy=(1-p.y)*0.5*renderer.domElement.clientHeight; L.el.style.display=''; L.el.style.left=Math.round(sx)+'px'; L.el.style.top=Math.round(sy)+'px'; } } catch(e){ console.error('updateLabels',e); } } updateLabels();

    // ---- DRAW & ERASE LOGIC (improved) ----
    const penBtn = document.getElementById('penBtn');
    const eraserBtn = document.getElementById('eraserBtn');
    const clearBtn = document.getElementById('clearBtn');
    const colorPicker = document.getElementById('colorPicker');
    const thicknessInput = document.getElementById('thickness');
    const thicknessVal = document.getElementById('thicknessVal');
    const eraserSizeInput = document.getElementById('eraserSize');
    const eraserVal = document.getElementById('eraserVal');
    const pointer = document.getElementById('pointer');

    let mode = null; let drawing = false; let currentLine = null; const lines = []; let nextId=1; let highlighted=null; let drawPlane = null; let planeDistance = 1000;

    // ensure controls exists
    let controls = (app && app.controls) || (window.controls) || null;
    if (!controls) {
      try { controls = new THREE.OrbitControls(camera, renderer.domElement); window.controls = controls; }
      catch(e){ console.warn('No controls available', e); controls = null; }
    }

    function setMode(m){ mode=m; penBtn.classList.toggle('active', m==='pen'); eraserBtn.classList.toggle('active', m==='eraser');
      if (controls) { if (m==='pen' || m==='eraser'){ controls.enableRotate=false; controls.enablePan=true; controls.enableZoom=true; } else { controls.enableRotate=true; } }
      updatePointer();
      // when entering pen mode prepare the camera-plane to draw on
      if (m==='pen'){
        // recompute plane from current camera orientation and position
        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
        const pointOnPlane = camera.position.clone().add(dir.clone().multiplyScalar(planeDistance));
        drawPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(dir.clone().negate(), pointOnPlane);
      } else if (m==='eraser'){
        // ensure pen doesn't run
        currentLine = null;
      } else drawPlane = null;
    }

    penBtn.addEventListener('click', async ()=>{ await line2Ready; setMode(mode==='pen'? null : 'pen'); });
    eraserBtn.addEventListener('click', async ()=>{ await line2Ready; setMode(mode==='eraser'? null : 'eraser'); });
    clearBtn.addEventListener('click', ()=>{ for (const L of lines) threeScene.remove(L.object3d); lines.length=0; highlighted=null; });
    thicknessInput.addEventListener('input', ()=> { thicknessVal.textContent = thicknessInput.value; updatePointer(); });
    eraserSizeInput.addEventListener('input', ()=> { eraserVal.textContent = eraserSizeInput.value; updatePointer(); });

    function updatePointer(){ const sz = mode==='eraser'? parseInt(eraserSizeInput.value,10) : parseInt(thicknessInput.value,10); pointer.style.width = Math.max(8,sz)+'px'; pointer.style.height = Math.max(8,sz)+'px'; pointer.classList.toggle('eraser', mode==='eraser'); }
    updatePointer();

    function makeLineObject(points, color, thickness){
      if (hasLine2 && THREE.LineGeometry && THREE.LineMaterial && THREE.Line2){
        const positions = [];
        for (const p of points) positions.push(p.x,p.y,p.z);
        const geom = new THREE.LineGeometry(); geom.setPositions(positions);
        const mat = new THREE.LineMaterial({ color: new THREE.Color(color).getHex(), linewidth: Math.max(0.0005, thickness/100), resolution: new THREE.Vector2(renderer.domElement.clientWidth, renderer.domElement.clientHeight) });
        mat.resolution = new THREE.Vector2(renderer.domElement.clientWidth, renderer.domElement.clientHeight);
        const line = new THREE.Line2(geom, mat); line.computeLineDistances(); line.scale.set(1,1,1);
        return { object3d: line, material: mat };
      } else {
        const geom = new THREE.BufferGeometry().setFromPoints(points);
        const mat = new THREE.LineBasicMaterial({ color: color, linewidth: thickness });
        const line = new THREE.Line(geom, mat);
        return { object3d: line, material: mat };
      }
    }

    function addPointToLineObj(lineObj, points){
      if (hasLine2 && lineObj.object3d.isLine2){
        const positions = [];
        for (const p of points) positions.push(p.x,p.y,p.z);
        lineObj.object3d.geometry.setPositions(positions);
        lineObj.material.resolution.set(renderer.domElement.clientWidth, renderer.domElement.clientHeight);
        lineObj.object3d.computeLineDistances();
        lineObj.object3d.geometry.needsUpdate = true;
      } else {
        lineObj.object3d.geometry.setFromPoints(points);
        if (lineObj.object3d.geometry.attributes && lineObj.object3d.geometry.attributes.position) lineObj.object3d.geometry.attributes.position.needsUpdate = true;
      }
    }

    function toScreenPosition(v3){ const v = v3.clone().project(camera); const x=(v.x+1)*0.5*renderer.domElement.clientWidth; const y=(1-v.y)*0.5*renderer.domElement.clientHeight; return {x,y,z:v.z}; }

    // find nearest line segment within radius px; returns {line,segIndex,ptIndex,closestPoint,dist}
    function findNearestLineSegment(mouseX, mouseY, radiusPx){ let best=null; let bestDist=Infinity; for (const L of lines){ const pts=L.points; for (let i=0;i<pts.length-1;i++){ const a=toScreenPosition(pts[i]); const b=toScreenPosition(pts[i+1]); const dx=b.x-a.x; const dy=b.y-a.y; const l2=dx*dx+dy*dy; let t=0; if (l2>1e-6) t = ((mouseX-a.x)*dx + (mouseY-a.y)*dy)/l2; t = Math.max(0, Math.min(1, t)); const px = a.x + t*dx; const py = a.y + t*dy; const dist = Math.hypot(mouseX-px, mouseY-py); if (dist < bestDist){ bestDist = dist; const cp = new THREE.Vector3().lerpVectors(pts[i], pts[i+1], t); best = { line:L, segIndex:i, segT:t, closestPoint:cp, dist }; } } } if (best && best.dist <= radiusPx) return best; return null; }

    function setHighlight(L){ if (highlighted === L) return; // restore old
      if (highlighted){ try{ highlighted.object3d.material.color.set(highlighted.color); if (hasLine2 && highlighted.object3d.isLine2) highlighted.object3d.material.linewidth = Math.max(0.0005, highlighted.thickness/100); highlighted.highlighted=false; }catch(e){} }
      highlighted = L;
      if (highlighted){ try{ if (highlighted.object3d.material) highlighted.object3d.material.color.set(0xFFFF00); if (hasLine2 && highlighted.object3d.isLine2) highlighted.object3d.material.linewidth = Math.max(0.0008, highlighted.thickness/80); highlighted.highlighted=true; }catch(e){} }
    }

    // Erase piecewise: remove points within radius in screen space and rebuild resulting chunks
    function erasePieceAt(mouseX, mouseY, radiusPx){ const found = findNearestLineSegment(mouseX, mouseY, radiusPx); if (!found) return false; const L = found.line; const pts = L.points; const keep = pts.map(p=>{ const s = toScreenPosition(p); return (Math.hypot(mouseX - s.x, mouseY - s.y) > radiusPx); });
      // build chunks of consecutive kept points of length>=2
      const chunks = []; let cur = null; for (let i=0;i<keep.length;i++){ if (keep[i]){ if (!cur) cur = []; cur.push(pts[i].clone()); } else { if (cur && cur.length>=2) { chunks.push(cur); } cur=null; } }
      if (cur && cur.length>=2) chunks.push(cur);
      // remove original line object
      threeScene.remove(L.object3d);
      const idx = lines.indexOf(L); if (idx>=0) lines.splice(idx,1);
      // create new lines for chunks
      for (const c of chunks){ const obj = makeLineObject(c, L.color, L.thickness); const newLine = { id: nextId++, object3d: obj.object3d, material: obj.material, points: c, color: L.color, thickness: L.thickness, opacity: 1.0 }; threeScene.add(newLine.object3d); lines.push(newLine); }
      return true;
    }

    // events
    const domEl = renderer.domElement; let mouse={x:0,y:0};
    domEl.addEventListener('pointermove', onPointerMove);
    domEl.addEventListener('pointerdown', onPointerDown);
    domEl.addEventListener('pointerup', onPointerUp);

    function getRay(clientX, clientY){ const rect = domEl.getBoundingClientRect(); const ndcX = ((clientX-rect.left)/domEl.clientWidth)*2 -1; const ndcY = -(((clientY-rect.top)/domEl.clientHeight)*2 -1); const rc = new THREE.Raycaster(); rc.setFromCamera(new THREE.Vector2(ndcX, ndcY), camera); return rc; }

    function onPointerMove(ev){ const rect = domEl.getBoundingClientRect(); mouse.x = ev.clientX - rect.left; mouse.y = ev.clientY - rect.top; pointer.style.left = ev.clientX + 'px'; pointer.style.top = ev.clientY + 'px';
      if (mode === 'eraser'){
        const seg = findNearestLineSegment(mouse.x, mouse.y, parseInt(eraserSizeInput.value,10));
        setHighlight(seg ? seg.line : null);
      }
      if (drawing && mode === 'pen' && currentLine){
        // intersect ray with current drawPlane (recompute plane so pan/zoom keep plane aligned with camera orientation)
        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
        const pointOnPlane = camera.position.clone().add(dir.clone().multiplyScalar(planeDistance));
        drawPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(dir.clone().negate(), pointOnPlane);
        const rc = getRay(ev.clientX, ev.clientY);
        const pt = new THREE.Vector3(); rc.ray.intersectPlane(drawPlane, pt);
        if (pt){ const last = currentLine.points[currentLine.points.length-1]; if (!last || last.distanceTo(pt) > 0.01){ currentLine.points.push(pt.clone()); addPointToLineObj(currentLine, currentLine.points); } }
      }
      if (drawing && mode === 'eraser'){
        // erase continuously, piecewise
        erasePieceAt(mouse.x, mouse.y, parseInt(eraserSizeInput.value,10));
      }
    }

    async function onPointerDown(ev){ if (ev.button !== 0) return; await line2Ready; if (mode === 'pen'){ drawing = true; currentLine = { id: nextId++, points: [], color: colorPicker.value, thickness: parseInt(thicknessInput.value,10) };
        // initial point
        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
        const pointOnPlane = camera.position.clone().add(dir.clone().multiplyScalar(planeDistance));
        drawPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(dir.clone().negate(), pointOnPlane);
        const rc = getRay(ev.clientX, ev.clientY); const pt = new THREE.Vector3(); rc.ray.intersectPlane(drawPlane, pt); if (pt) currentLine.points.push(pt.clone()); const obj = makeLineObject(currentLine.points, currentLine.color, currentLine.thickness); currentLine.object3d = obj.object3d; currentLine.material = obj.material; currentLine.color = currentLine.color; currentLine.opacity = currentLine.object3d.material.opacity || 1.0; threeScene.add(currentLine.object3d); lines.push(currentLine);
      } else if (mode === 'eraser'){
        // erase only when clicking on a line segment (piecewise)
        const rect = domEl.getBoundingClientRect(); const mx = ev.clientX - rect.left; const my = ev.clientY - rect.top; const done = erasePieceAt(mx, my, parseInt(eraserSizeInput.value,10)); if (done) setHighlight(null); drawing = true;
      }
    }

    function onPointerUp(ev){ if (ev.button !== 0) return; drawing = false; currentLine = null; }

    window.addEventListener('resize', ()=>{ if (hasLine2) for (const L of lines) if (L.object3d && L.object3d.material && L.object3d.material.resolution) L.object3d.material.resolution.set(renderer.domElement.clientWidth, renderer.domElement.clientHeight); });

    setMode(null);
    console.log('Pen & Eraser updated: Qgis2threejs UI restored, Line2 import handled, draw-plane locked to camera orientation, partial erase implemented.');

  } catch (err){ console.error('Error in scene callback', err); }
});
</script>
</body>
</html>
