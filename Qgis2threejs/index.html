<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>terremoti-07-2025</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<base target="_blank">
<link rel="stylesheet" type="text/css" href="./Qgis2threejs.css">
<style type="text/css">
#popup, #header, #layerpanel {
  left: 36px;
}
</style>
<script src="./threejs/three.min.js"></script>
<script src="./threejs/OrbitControls.js"></script>
<script src="./threejs/ViewHelper.js"></script>
<script src="./threejs/OutlineEffect.js"></script>
<script src="./Qgis2threejs.js"></script>
</head>
<body>
<div id="view">
  <div id="northarrow"></div>
  <div id="navigation"></div>
</div>

<!-- popup -->
<div id="popup">
  <div id="closebtn">&times;</div>
  <div id="popupbar"></div>
  <div id="popupbody">
    <div id="popupcontent"></div>

    <!-- query result -->
    <div id="queryresult">
      <table id="qr_coords_table">
        <caption>Clicked coordinates <div id="zoomtopoint" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_coords"></td></tr>
      </table>

      <table id="qr_layername_table">
        <caption>Layer <div id="zoomtolayer" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_layername"></td></tr>
      </table>

      <table id="qr_attrs_table">
        <caption>Attributes</caption>
      </table>

      <!-- camera actions and measure tool -->
      <div id="orbitbtn" class="action-btn action-orbit">Orbit</div>
      <div id="measurebtn" class="action-btn">Measure distance</div>
    </div>

    <!-- page info -->
    <div id="pageinfo">
      <h1>Current View URL</h1>
      <div><input id="urlbox" type="text"></div>

      <h1>Usage</h1>
      <table id="usage">
        <tr><td colspan="2" class="star">Mouse</td></tr>
        <tr><td>Left button + Move</td><td>Orbit</td></tr>
        <tr><td>Mouse Wheel</td><td>Zoom</td></tr>
        <tr><td>Right button + Move</td><td>Pan</td></tr>

        <tr><td colspan="2" class="star">Keys</td></tr>
        <tr><td>Arrow keys</td><td>Move Horizontally</td></tr>
        <tr><td>Shift + Arrow keys</td><td>Orbit</td></tr>
        <tr><td>Ctrl + Arrow keys</td><td>Rotate</td></tr>
        <tr><td>Shift + Ctrl + Up / Down</td><td>Zoom In / Out</td></tr>
        <tr><td>L</td><td>Toggle Label Visibility</td></tr>
        <tr><td>R</td><td>Start / Stop Orbit Animation</td></tr>
        <tr><td>W</td><td>Wireframe Mode</td></tr>
        <tr><td>Shift + R</td><td>Reset Camera Position</td></tr>
        <tr><td>Shift + S</td><td>Save Image</td></tr>
      </table>

      <h1>About</h1>
      <div id="about"><img src="./Qgis2threejs.png">
        This page was made with <a href="https://www.qgis.org/">QGIS</a> and <a href="https://github.com/minorua/Qgis2threejs">Qgis2threejs</a> plugin (version 2.8).
        <div>Powered by <a href="https://threejs.org/">three.js</a>
        <span id="lib_proj4js"> and <a href="https://trac.osgeo.org/proj4js/">Proj4js</a></span>.</div>
      </div>
    </div>
  </div>
</div>

<!-- progress bar -->
<div id="progress"><div id="progressbar"></div></div>

<!-- menu -->
<div id="toolbtns">
  <div id="layerbtn"></div>
  <div id="animbtn" class="hidden"></div>
  <div id="infobtn"></div>
</div>

<!-- header and footer -->
<div id="header"></div>
<div id="footer"></div>

<!-- layer panel -->
<div id="layerpanel">
  <div id="layerlist"></div>
</div>

<!-- animation -->
<div id="narrativebox" class="ef1">
  <div id="narbody">

  </div>
  <div id="nextbtn"></div>
</div>

<script>
Q3D.Config.allVisible = true;
Q3D.Config.bgColor = 0xffffff;
Q3D.Config.viewpoint = {lookAt:{x:426248.434989865,y:4517666.811603576,z:-1.1839921050606837e-15},pos:{x:432420.6401290015,y:4504911.042410877,z:3937.8688261482375}};
Q3D.Config.localMode = true;

var container = document.getElementById("view"),
    app = Q3D.application,
    gui = Q3D.gui;

app.init(container);       // initialize viewer

// load the scene
app.loadSceneFile("./data/index/scene.js", function (scene) {
  // scene file has been loaded
  app.start();
}, function (scene) {
  // all relevant files have been loaded

});
</script>
  <!-- Inserisci questo codice prima di </body> nel file index.html esportato da Qgis2threejs -->
<style>
/* mantiene esattamente lo stile delle etichette che avevamo prima */
.label2d {
  padding:2px 6px;
  background:rgba(255,255,255,0.95);
  border:1px solid #000;
  color:#000;
  font-weight:700;
  font-size:12px;
  border-radius:3px;
  white-space:nowrap;
  pointer-events:none;
  position: absolute;
  transform: translate(-50%, -50%);
  will-change: transform;
}
</style>

<script>
(function(){

  // --- CONFIG ---
  const DEPTH = 10000;        // profondità (m) -> creeremo da surface a surface - DEPTH
  const LABEL_STEP = 1000;    // ogni 1000 m
  const LABEL_OFFSET_PX = 30; // distanza in pixel dalle superfici (per le label DOM)
  // -------------


  // utility: attendi che scene, camera, renderer esistano (Qgis2threejs assegna variabili globali)
  function waitForViewer(timeout = 8000) {
    return new Promise((resolve, reject) => {
      const start = Date.now();
      (function tick(){
        // i nomi usati dall'export di Qgis2threejs variano, ma in genere esistono:
        // - THREE (lib)
        // - scene
        // - camera
        // - renderer
        if (window.THREE && (window.scene || window.viewerScene || window.viewer && window.viewer.scene) && (window.camera || window.viewer && window.viewer.camera) && (window.renderer || window.viewer && window.viewer.renderer)) {
          // preferenze: usa scene/camera/renderer dall'export, se non esistono usa viewer.*
          const s = window.scene || (window.viewer && window.viewer.scene) || window.viewerScene;
          const c = window.camera || (window.viewer && window.viewer.camera) || window.viewerCamera;
          const r = window.renderer || (window.viewer && window.viewer.renderer) || window.viewerRenderer;
          return resolve({ THREE: window.THREE, scene: s, camera: c, renderer: r });
        }
        if (Date.now() - start > timeout) return reject(new Error('Viewer non trovato (scene/camera/renderer). Assicurati di incollare questo script DOPO gli script di Qgis2threejs).'));
        requestAnimationFrame(tick);
      }());
    });
  }

  function findDTM(scene, THREE) {
    let dtm = scene.getObjectByName && scene.getObjectByName('DTM');
    if (dtm) return dtm;

    // cerca mesh che contiene 'dtm' nel nome
    let found = null;
    scene.traverse(obj => {
      if (!found && obj.isMesh && obj.name && typeof obj.name === 'string' && obj.name.toLowerCase().includes('dtm')) found = obj;
    });
    if (found) return found;

    // fallback: la mesh con area footprint più grande
    let maxArea = -Infinity, best = null;
    scene.traverse(obj => {
      if (obj.isMesh) {
        const bb = new THREE.Box3().setFromObject(obj);
        const s = new THREE.Vector3(); bb.getSize(s);
        // area = prodotto delle due dimensioni maggiori
        const arr = [s.x, s.y, s.z].sort((a,b)=>b-a);
        const area = arr[0]*arr[1];
        if (area > maxArea) { maxArea = area; best = obj; }
      }
    });
    return best;
  }

  // proietta posizione 3D -> schermo e posiziona un DIV (label)
  function projectToScreen(pos3, camera, renderer) {
    const width = renderer.domElement.clientWidth;
    const height = renderer.domElement.clientHeight;
    const p = pos3.clone().project(camera);
    return {
      x: (p.x + 1) * 0.5 * width,
      y: (1 - p.y) * 0.5 * height,
      z: p.z
    };
  }

  // aggiunge label DOM e la tiene aggiornata
  function createLabelDOM(text, pos3) {
    const div = document.createElement('div');
    div.className = 'label2d';
    div.textContent = text;
    document.body.appendChild(div);
    return { el: div, pos: pos3.clone() };
  }

  // main
  waitForViewer().then(({THREE, scene, camera, renderer}) => {

    // trova la DTM
    const dtm = findDTM(scene, THREE);
    if (!dtm) { console.warn('DTM non trovato nella scena.'); return; }

    // rendi la DTM sempre visibile (semi-trasparente)
    dtm.traverse(m => {
      if (m.isMesh) {
        const mats = Array.isArray(m.material) ? m.material : [m.material];
        for (const mat of mats) {
          if (!mat) continue;
          if (typeof mat.opacity !== 'number' || mat.opacity === 1) mat.opacity = 0.6;
          mat.transparent = true;
          mat.depthTest = false;
          mat.depthWrite = false;
          mat.side = THREE.DoubleSide;
          mat.needsUpdate = true;
        }
        m.renderOrder = 999;
      }
    });

    // bounding box del DTM
    const bb = new THREE.Box3().setFromObject(dtm);
    const size = new THREE.Vector3(); bb.getSize(size);
    const center = new THREE.Vector3(); bb.getCenter(center);

    // determiniamo l'asse verticale come la dimensione minore del bbox totale (come fatto prima)
    const totalBbox = new THREE.Box3().setFromObject(scene);
    const totalSize = new THREE.Vector3(); totalBbox.getSize(totalSize);
    let vertIndex = 1; // default Y
    if (totalSize.x <= totalSize.y && totalSize.x <= totalSize.z) vertIndex = 0;
    else if (totalSize.z <= totalSize.x && totalSize.z <= totalSize.y) vertIndex = 2;
    const axes2 = [0,1,2].filter(i=>i!==vertIndex);

    // corner 2D in basso a destra = (max su axes2[0], min su axes2[1])
    const maxA = bb.max.getComponent(axes2[0]);
    const minB = bb.min.getComponent(axes2[1]);

    // prendiamo la quota della superficie (top) come bb.max sul vertIndex
    const surfaceZ = bb.max.getComponent(vertIndex);
    const topZ = surfaceZ;
    const bottomZ = surfaceZ - DEPTH;

    // costruzione angoli (top e bottom)
    // Top ordering: 0 = basso-destra (maxA,minB), 1=alto-destra, 2=alto-sin, 3=basso-sin
    const topCorners = [];
    topCorners.push(new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], minB).setComponent(vertIndex, topZ));
    topCorners.push(new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], bb.max.getComponent(axes2[1])).setComponent(vertIndex, topZ));
    topCorners.push(new THREE.Vector3().setComponent(axes2[0], bb.min.getComponent(axes2[0])).setComponent(axes2[1], bb.max.getComponent(axes2[1])).setComponent(vertIndex, topZ));
    topCorners.push(new THREE.Vector3().setComponent(axes2[0], bb.min.getComponent(axes2[0])).setComponent(axes2[1], minB).setComponent(vertIndex, topZ));

    const bottomCorners = topCorners.map(c => c.clone().setComponent(vertIndex, bottomZ));

    // disegna contorni: top rect, bottom rect, verticali (12 linee)
    const matLine = new THREE.LineBasicMaterial({ color: 0x000000 });
    function addLine(p1, p2) {
      const geom = new THREE.BufferGeometry().setFromPoints([p1.clone(), p2.clone()]);
      const line = new THREE.Line(geom, matLine);
      scene.add(line);
      return line;
    }
    // top rectangle
    addLine(topCorners[0], topCorners[1]);
    addLine(topCorners[1], topCorners[2]);
    addLine(topCorners[2], topCorners[3]);
    addLine(topCorners[3], topCorners[0]);
    // bottom rectangle
    addLine(bottomCorners[0], bottomCorners[1]);
    addLine(bottomCorners[1], bottomCorners[2]);
    addLine(bottomCorners[2], bottomCorners[3]);
    addLine(bottomCorners[3], bottomCorners[0]);
    // verticals
    for (let i=0;i<4;i++) addLine(topCorners[i], bottomCorners[i]);

    // Aggiungi etichette SOLO sulla colonna in basso-destra (topCorners[0] -> bottomCorners[0]) ogni LABEL_STEP
    const labels = [];
    const cornerTop = topCorners[0].clone();
    // outward direction (footprint) per offset delle etichette
    const centerFoot = new THREE.Vector3();
    centerFoot.setComponent(axes2[0], (bb.max.getComponent(axes2[0])+bb.min.getComponent(axes2[0]))/2 );
    centerFoot.setComponent(axes2[1], (bb.max.getComponent(axes2[1])+bb.min.getComponent(axes2[1]))/2 );
    centerFoot.setComponent(vertIndex, 0);
    const dirOut = cornerTop.clone().setComponent(vertIndex,0).sub(centerFoot.clone().setComponent(vertIndex,0));
    if (dirOut.lengthSq() < 1e-6) { dirOut.setComponent(axes2[0],1); dirOut.setComponent(axes2[1],0); }
    dirOut.setComponent(vertIndex,0); dirOut.normalize();

    for (let d = LABEL_STEP; d <= DEPTH; d += LABEL_STEP) {
      const z = topZ - d;
      const pos = cornerTop.clone().setComponent(vertIndex, z);
      const offseted = pos.clone().add(dirOut.clone().multiplyScalar(LABEL_OFFSET_PX * 0.01 * Math.max(bb.getSize(new THREE.Vector3()).x, bb.getSize(new THREE.Vector3()).y)));
      const lbl = createLabelDOM(`-${d} m`, offseted);
      labels.push(lbl);
    }

    // aggiorna posizioni label ad ogni render (usa requestAnimationFrame)
    function updateLabels() {
      for (const L of labels) {
        const screen = projectToScreen(L.pos, camera, renderer);
        // se dietro la camera non mostrare
        if (screen.z < -1 || screen.z > 1) {
          L.el.style.display = 'none';
        } else {
          L.el.style.display = '';
          L.el.style.left = `${Math.round(screen.x)}px`;
          L.el.style.top  = `${Math.round(screen.y)}px`;
        }
      }
    }

    // Hook: chiama updateLabels ad ogni frame. Qgis2threejs ha già un loop, ma facciamo il nostro RAF per sicurezza
    (function loop(){
      requestAnimationFrame(loop);
      try { updateLabels(); } catch(e){ /* ignore */ }
    })();

    console.log('Parallelepipedo aggiunto: top=',topZ,' bottom=',bottomZ,' corner (XY)=', maxA, minB);

    // Se vuoi invece *traslare l'intero modello* così che il corner scelto abbia Z=0 (cioè superficie === 0m nell'intero viewer),
    // puoi abilitare questa riga (ATTENZIONE: può cambiare posizionamento degli altri layers):
    // const delta = topZ; scene.position && (scene.position.setComponent(vertIndex, (scene.position.getComponent(vertIndex) || 0) - delta));

  }).catch(err => {
    console.error(err);
    alert('Impossibile trovare il viewer (scene/camera/renderer). Incolla questo script DOPO gli script generati da Qgis2threejs.');
  });

})();
</script>
</body>
</html>
