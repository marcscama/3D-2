<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>terremoti-07-2025</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<base target="_blank">
<link rel="stylesheet" type="text/css" href="./Qgis2threejs.css">
<style type="text/css">
#popup, #header, #layerpanel {
  left: 36px;
}
.label2d {
  padding:2px 6px;
  background:rgba(255,255,255,0.95);
  border:1px solid #000;
  color:#000;
  font-weight:700;
  font-size:12px;
  border-radius:3px;
  white-space:nowrap;
  pointer-events:none;
  position:absolute;
  transform:translate(-50%,-50%);
  z-index: 100;
}
</style>
<script src="./threejs/three.min.js"></script>
<script src="./threejs/OrbitControls.js"></script>
<script src="./threejs/ViewHelper.js"></script>
<script src="./threejs/OutlineEffect.js"></script>
<script src="./Qgis2threejs.js"></script>
</head>
<body>
  <div id="container"></div>
  <div id="toolbar">
    <button id="penButton">‚úèÔ∏è Penna</button>
    <button id="eraserButton">ü©π Gomma</button>
    <button id="resetButton">üîÑ Reset</button>
    <label style="display:block;margin-top:6px">Colore <input id="color" type="color" value="#ff0000"></label>
    <label>Spessore <input id="thickness" type="range" min="1" max="30" value="6"></label>
    <label>Eraser size <input id="eraserSize" type="range" min="8" max="120" value="32"></label>
  </div>
  <!-- Line2 locali (dal tuo repo in ./lines/) -->
  <script src="./lines/LineGeometry.js"></script>
  <script src="./lines/LineMaterial.js"></script>
  <script src="./lines/Line2.js"></script>

  <!-- Qgis2threejs core (preserved) -->
  <script src="Qgis2threejs.js"></script>

  <script>
    // Basic scene setup
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 20000);
    camera.position.set(400, 400, 800);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    container.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(100,200,100); scene.add(dir);

    // --- Parallelepipedo (DTM placeholder) ---
    const boxSize = {x:800, y:600, z:400};
    const boxGeom = new THREE.BoxGeometry(boxSize.x, boxSize.y, boxSize.z);
    const boxMat = new THREE.MeshBasicMaterial({ color:0x999999, wireframe:true });
    const boxMesh = new THREE.Mesh(boxGeom, boxMat);
    boxMesh.position.set(0,0,0);
    scene.add(boxMesh);

    // compute bounding box in world coords
    const bbox = new THREE.Box3().setFromObject(boxMesh);

    // labels
    function addLabel(text, pos, rot=0){
      const canvas = document.createElement('canvas'); canvas.width=256; canvas.height=64;
      const ctx = canvas.getContext('2d'); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.fillRect(0,0,256,64);
      ctx.font='36px sans-serif'; ctx.fillStyle='black'; ctx.fillText(text,10,42);
      const tex = new THREE.CanvasTexture(canvas); const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex }));
      spr.position.copy(pos); spr.scale.set(100,25,1); spr.rotation.z=rot; scene.add(spr);
    }
    addLabel('Nord', new THREE.Vector3(0, boxSize.y/2 + 30, 0));
    addLabel('Sud', new THREE.Vector3(0, -boxSize.y/2 - 30, 0));
    addLabel('Est', new THREE.Vector3(boxSize.x/2 + 30, 0, 0));
    addLabel('Ovest', new THREE.Vector3(-boxSize.x/2 - 30, 0, 0));

    // --- Drawing state and helpers ---
    if (!(THREE.Line2 && THREE.LineGeometry && THREE.LineMaterial)) {
      console.error('Line2 modules not found. Make sure ./lines/LineGeometry.js, LineMaterial.js and Line2.js exist.');
    }

    let mode = null; // 'pen'|'eraser'|null
    let isPointerDown = false;
    let drawPlane = null; // THREE.Plane
    let current = null; // { id, points: [Vector3], object3d, material, thickness, color }
    const lines = []; // array of line objects
    let idCounter = 1;

    const ray = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    const colorInput = document.getElementById('color');
    const thicknessInput = document.getElementById('thickness');
    const eraserSizeInput = document.getElementById('eraserSize');

    function screenPos(v){ const p = v.clone().project(camera); return { x:(p.x+1)*0.5*renderer.domElement.clientWidth, y:(1-p.y)*0.5*renderer.domElement.clientHeight, z:p.z }; }

    function makeLineObject(pointsVec3, colorHex, thickness){
      const positions = [];
      for(const p of pointsVec3){ positions.push(p.x,p.y,p.z); }
      const geom = new THREE.LineGeometry(); geom.setPositions(positions);
      const mat = new THREE.LineMaterial({ color: new THREE.Color(colorHex).getHex(), linewidth: Math.max(0.0006, thickness/100) });
      mat.resolution.set(renderer.domElement.clientWidth, renderer.domElement.clientHeight);
      const line2 = new THREE.Line2(geom, mat);
      line2.computeLineDistances(); line2.scale.set(1,1,1);
      return { object3d: line2, material: mat };
    }

    function updateLineObject(lineObj){ const positions = []; for(const p of lineObj.points){ positions.push(p.x,p.y,p.z); } lineObj.object3d.geometry.setPositions(positions); if(lineObj.material && lineObj.material.resolution) lineObj.material.resolution.set(renderer.domElement.clientWidth, renderer.domElement.clientHeight); lineObj.object3d.geometry.needsUpdate=true; }

    function getBoxIntersectionPoint(event){ const rect = renderer.domElement.getBoundingClientRect(); mouse.x = ((event.clientX-rect.left)/rect.width)*2 -1; mouse.y = -((event.clientY-rect.top)/rect.height)*2 +1; ray.setFromCamera(mouse, camera);
      // intersect with box mesh (prefer), otherwise project to plane in front of camera clamped to bbox
      const hits = ray.intersectObject(boxMesh, true);
      if(hits && hits.length>0) return hits[0].point.clone();
      // fallback: intersect with plane orthogonal to camera through bbox center
      const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
      const center = bbox.getCenter(new THREE.Vector3());
      const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(dir.clone().negate(), center);
      const pt = new THREE.Vector3(); ray.ray.intersectPlane(plane, pt);
      if(pt) { bbox.clampPoint(pt, pt); return pt; }
      return null;
    }

    // find nearest line segment in screen space within radius px
    function findNearestSegment(mouseX, mouseY, radiusPx){ let best=null; let bestDist=Infinity; for(const L of lines){ const pts=L.points; for(let i=0;i<pts.length-1;i++){ const a=screenPos(pts[i]); const b=screenPos(pts[i+1]); const dx=b.x-a.x, dy=b.y-a.y, l2=dx*dx+dy*dy; let t=0; if(l2>1e-6) t = ((mouseX-a.x)*dx + (mouseY-a.y)*dy)/l2; t = Math.max(0, Math.min(1, t)); const px=a.x+t*dx, py=a.y+t*dy; const dist = Math.hypot(mouseX-px, mouseY-py); if(dist < bestDist){ bestDist = dist; const cp = new THREE.Vector3().lerpVectors(pts[i], pts[i+1], t); best = { line: L, segIndex: i, segT: t, closestPoint: cp, dist }; } } } if(best && best.dist <= radiusPx) return best; return null; }

    let highlighted = null;
    function setHighlight(L){ if(highlighted === L) return; if(highlighted){ try{ highlighted.object3d.material.color.set(highlighted.color); }catch(e){} highlighted = null; }
      highlighted = L; if(highlighted){ try{ highlighted.object3d.material.color.set(0xFFFF00); }catch(e){} }
    }

    // erase piecewise: remove points whose screen distance <= radiusPx, rebuild remaining chunks
    function erasePieceAt(mouseX, mouseY, radiusPx){ const found = findNearestSegment(mouseX, mouseY, radiusPx); if(!found) return false; const L = found.line; const pts = L.points; const keep = pts.map(p=>{ const s = screenPos(p); return Math.hypot(mouseX - s.x, mouseY - s.y) > radiusPx; });
      const chunks=[]; let cur=null; for(let i=0;i<keep.length;i++){ if(keep[i]){ if(!cur) cur=[]; cur.push(pts[i].clone()); } else { if(cur && cur.length>=2) chunks.push(cur); cur=null; } } if(cur && cur.length>=2) chunks.push(cur);
      // remove original
      scene.remove(L.object3d); const idx = lines.indexOf(L); if(idx>=0) lines.splice(idx,1);
      // add chunks
      for(const c of chunks){ const obj = makeLineObject(c, L.color, L.thickness); obj.object3d.userData._id = idCounter++; scene.add(obj.object3d); lines.push({ id: obj.object3d.userData._id, points: c, object3d: obj.object3d, material: obj.material, color: L.color, thickness: L.thickness }); }
      return true;
    }

    // mouse handlers
    function onPointerDown(e){ isPointerDown = true; if(mode === 'pen'){
        // start new line
        const pt = getBoxIntersectionPoint(e); if(!pt) return; drawPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()).clone().negate(), pt);
        const points = [pt.clone()]; const color = colorInput.value; const thickness = parseInt(thicknessInput.value,10);
        const obj = makeLineObject(points, color, thickness); obj.object3d.userData._id = idCounter++;
        scene.add(obj.object3d);
        current = { id: obj.object3d.userData._id, points: points, object3d: obj.object3d, material: obj.material, color: color, thickness: thickness };
        lines.push(current);
      } else if(mode === 'eraser'){
        const rect = renderer.domElement.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; const done = erasePieceAt(mx, my, parseInt(eraserSizeInput.value,10)); if(done) setHighlight(null);
      }
    }

    function onPointerMove(e){ const rect = renderer.domElement.getBoundingClientRect(); const mx = e.clientX - rect.left; const my = e.clientY - rect.top; if(mode === 'eraser'){
        const seg = findNearestSegment(mx, my, parseInt(eraserSizeInput.value,10)); setHighlight(seg ? seg.line : null);
      }
      if(isPointerDown && mode === 'pen' && current){ const rc = new THREE.Raycaster(); const ndc = new THREE.Vector2(((e.clientX-rect.left)/rect.width)*2-1, -(((e.clientY-rect.top)/rect.height)*2-1)); rc.setFromCamera(ndc, camera); const pt = new THREE.Vector3(); rc.ray.intersectPlane(drawPlane, pt); if(pt){ bbox.clampPoint(pt, pt); const last = current.points[current.points.length-1]; if(!last || last.distanceTo(pt) > 0.5){ current.points.push(pt.clone()); updateLineObject(current); } } }
    }

    function onPointerUp(e){ isPointerDown = false; current = null; }

    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);

    // toolbar
    document.getElementById('penButton').addEventListener('click', ()=>{ mode='pen'; controls.enableRotate=false; controls.enablePan=true; controls.enableZoom=true; });
    document.getElementById('eraserButton').addEventListener('click', ()=>{ mode='eraser'; controls.enableRotate=false; controls.enablePan=true; controls.enableZoom=true; });
    document.getElementById('resetButton').addEventListener('click', ()=>{ mode=null; controls.enableRotate=true; setHighlight(null); });

    // resize
    window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); for(const L of lines) if(L.material && L.material.resolution) L.material.resolution.set(renderer.domElement.clientWidth, renderer.domElement.clientHeight); });

    // animation
    function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    animate();

    console.log('Pen & Eraser (Line2) ready ‚Äî draw plane clamped to parallelepiped.');
  </script>
</body>
</html>
