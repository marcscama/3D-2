<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Terremoti nei Campi Flegrei dal 2005 al 07-2025, con MD>=2 test9</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<base target="_blank">
<link rel="stylesheet" type="text/css" href="./Qgis2threejs.css">
<style>
/* Stili UI e annotazioni (come da tuo file) */
#drawUI { position:absolute; top:12px; right:12px; background:rgba(255,255,255,0.95); border-radius:10px; padding:10px 12px; box-shadow:0 4px 12px rgba(0,0,0,0.18); z-index:3000; font-family:system-ui,sans-serif; width:calc(20%+180px); max-width:300px; }
#drawUI h3 { margin:0 0 8px 0; font-size:14px; font-weight:700; }
.ui-row { display:flex; align-items:center; gap:8px; margin:8px 0; }
.tool { padding:6px 10px; border-radius:8px; border:1px solid #c6c6c6; background:#f7f7f7; cursor:pointer; font-weight:600; font-size:12px; }
.tool.active { background:#0a84ff; color:#fff; border-color:#066fd6; }
input[type=color]{ width:36px; height:28px; border:none; }
input[type=range]{ width:80px; }
#pointer { position:fixed; pointer-events:none; z-index:3500; width:18px; height:18px; border-radius:50%; transform:translate(-50%,-50%); border:2px solid rgba(0,0,0,0.65); background:rgba(255,255,255,0.2); }
#pointer.eraser { border:2px dashed rgba(0,0,0,0.65); background:rgba(255,255,255,0.1); }
</style>

<!-- three.js core + controls/effects -->
<script src="./threejs/three.min.js"></script>
<script src="./threejs/OrbitControls.js"></script>
<script src="./threejs/ViewHelper.js"></script>
<script src="./threejs/OutlineEffect.js"></script>

<!-- Line2 non-module -->
<script src="./threejs/lines/LineSegmentsGeometry.js"></script>
<script src="./threejs/lines/LineSegments2.js"></script>
<script src="./threejs/lines/LineGeometry.js"></script>
<script src="./threejs/lines/LineMaterial.js"></script>
<script src="./threejs/lines/Line2.js"></script>

<!-- Qgis2threejs -->
<script src="./Qgis2threejs.js"></script>
</head>
<body>
<div id="view"></div>

<!-- UI Annotazioni -->
<div id="drawUI">
  <h3>Annotazioni</h3>
  <div class="ui-row">
    <button id="penBtn" class="tool">‚úèÔ∏è Penna</button>
    <button id="eraserBtn" class="tool">üßΩ Gomma</button>
    <button id="clearBtn" class="tool">üóë Svuota</button>
  </div>
  <div class="ui-row">
    <label>Colore</label><input id="colorPicker" type="color" value="#ff0000">
  </div>
  <div class="ui-row">
    <label>Spessore</label><input id="thickness" type="range" min="1" max="24" value="4"><span id="thicknessVal">4</span>
  </div>
  <div class="ui-row">
    <label>Gomma</label><input id="eraserSize" type="range" min="8" max="96" value="32"><span id="eraserVal">32</span>
  </div>
</div>
<div id="pointer"></div>

<script>
// ====== Config Qgis2threejs ======
Q3D.Config.allVisible = true;
Q3D.Config.bgColor = 0xffffff;
var container = document.getElementById("view");
var app = Q3D.application;
try { app.init(container); } catch(e){ console.error(e); }

// ====== Callback caricamento scena ======
app.loadSceneFile("./data/index/scene.js", function(scene){
  const THREE_ = window.THREE;
  const threeScene = scene || (app && app.scene);
  const camera = (app && app.camera);
  const renderer = (app && app.renderer);
  const controls = (app && app.controls);

  if (!THREE_ || !threeScene || !camera || !renderer) return;

  // Bounding box DTM/parallelepipedo
  let dtm = null;
  threeScene.traverse(obj=>{ if(obj.userData?.layerId===2) dtm=obj; });
  const bb = new THREE_.Box3().setFromObject(dtm || threeScene);
  const size = bb.getSize(new THREE_.Vector3());

  const vertIndex = 2;
  const axes2 = [0,1];
  const minA = bb.min.x, maxA = bb.max.x;
  const minB = bb.min.y, maxB = bb.max.y;

  const DEPTH=10000, STEP=1000, LABEL_OFFSET=30;
  const topZ=0, bottomZ=-DEPTH;
  const topCorners=[
    new THREE_.Vector3(maxA,minB,topZ), new THREE_.Vector3(maxA,maxB,topZ),
    new THREE_.Vector3(minA,maxB,topZ), new THREE_.Vector3(minA,minB,topZ)
  ];
  const bottomCorners=topCorners.map(c=>c.clone().setZ(bottomZ));
  const matLine = new THREE_.LineBasicMaterial({color:0x000000,linewidth:2,opacity:0.8,transparent:true});
  function addLine(p1,p2){ const geom=new THREE_.BufferGeometry().setFromPoints([p1,p2]); threeScene.add(new THREE_.Line(geom,matLine)); }

  for(let i=0;i<4;i++){ addLine(topCorners[i],topCorners[(i+1)%4]); addLine(bottomCorners[i],bottomCorners[(i+1)%4]); addLine(topCorners[i],bottomCorners[i]); }
  const pbox = new THREE_.Box3(new THREE_.Vector3(minA,minB,bottomZ), new THREE_.Vector3(maxA,maxB,topZ));

  // ======= Annotazioni =======
  const penBtn=document.getElementById('penBtn'), eraserBtn=document.getElementById('eraserBtn'), clearBtn=document.getElementById('clearBtn');
  const colorPicker=document.getElementById('colorPicker'), thicknessInput=document.getElementById('thickness'), thicknessVal=document.getElementById('thicknessVal');
  const eraserSizeInput=document.getElementById('eraserSize'), eraserVal=document.getElementById('eraserVal'), pointer=document.getElementById('pointer');

  let mode=null,drawing=false,currentLine=null,lines=[],nextId=1,drawPlane=null,planeFixed=false;

  function setMode(m){
    if(m==='pen'){ eraserBtn.classList.remove('active'); }
    if(m==='eraser'){ penBtn.classList.remove('active'); }
    mode=(mode===m)?null:m;
    penBtn.classList.toggle('active',mode==='pen');
    eraserBtn.classList.toggle('active',mode==='eraser');
    if(controls){
      controls.enableRotate=!(mode==='pen'||mode==='eraser');
      controls.enablePan=(mode==='pen'||mode==='eraser');
      controls.enableZoom=(mode==='pen'||mode==='eraser');
    }
    if(mode==='pen'){ drawPlane=null; planeFixed=false; }
    updatePointer();
  }

  function updatePointer(){
    const sz=mode==='eraser'?parseInt(eraserSizeInput.value,10):parseInt(thicknessInput.value,10);
    pointer.style.width=Math.max(10,sz)+'px'; pointer.style.height=Math.max(10,sz)+'px';
    pointer.classList.toggle('eraser', mode==='eraser');
  }

  penBtn.addEventListener('click',()=>setMode('pen'));
  eraserBtn.addEventListener('click',()=>setMode('eraser'));
  clearBtn.addEventListener('click',()=>{ for(const L of lines) threeScene.remove(L.object3d); lines=[]; });

  thicknessInput.addEventListener('input',()=>{ thicknessVal.textContent=thicknessInput.value; updatePointer(); });
  eraserSizeInput.addEventListener('input',()=>{ eraserVal.textContent=eraserSizeInput.value; updatePointer(); });

  function makeLineObject(points,color,thickness){
    if(!(THREE.Line2 && THREE.LineGeometry && THREE.LineMaterial)){
      return { object3d: new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), new THREE.LineBasicMaterial({color,linewidth:1})), material:null };
    }
    const positions=[]; for(const p of points) positions.push(p.x,p.y,p.z);
    const geom=new THREE.LineGeometry(); geom.setPositions(positions);
    const mat=new THREE.LineMaterial({color:new THREE.Color(color).getHex(), linewidth:Math.max(0.0006,thickness/20), transparent:true, opacity:1.0, depthTest:true});
    mat.resolution=new THREE.Vector2(renderer.domElement.clientWidth, renderer.domElement.clientHeight);
    const line=new THREE.Line2(geom,mat); line.computeLineDistances(); line.frustumCulled=false; line.renderOrder=1000; if(line.material) line.material.needsUpdate=true;
    return { object3d:line, material:mat };
  }

  function addPointToLineObj(lineObj, points){
    if(lineObj.object3d.isLine2){
      const positions=[]; for(const p of points) positions.push(p.x,p.y,p.z);
      lineObj.object3d.geometry.setPositions(positions);
      if(lineObj.object3d.material && lineObj.object3d.material.resolution) lineObj.object3d.material.resolution.set(renderer.domElement.clientWidth, renderer.domElement.clientHeight);
      lineObj.object3d.computeLineDistances();
      lineObj.object3d.geometry.needsUpdate=true;
    } else { lineObj.object3d.geometry.setFromPoints(points); lineObj.object3d.geometry.needsUpdate=true; }
  }

  function getRay(clientX,clientY){
    const rect=renderer.domElement.getBoundingClientRect();
    const ndcX=((clientX-rect.left)/rect.width)*2-1;
    const ndcY=-(((clientY-rect.top)/rect.height)*2-1);
    const rc=new THREE.Raycaster();
    rc.setFromCamera(new THREE.Vector2(ndcX,ndcY),camera);
    return rc;
  }

  function clampToParallelepiped(pt){ return pbox.clampPoint(pt,pt); }

  function onPointerMove(ev){
    const rect=renderer.domElement.getBoundingClientRect();
    const mouseX=ev.clientX-rect.left, mouseY=ev.clientY-rect.top;
    pointer.style.left=ev.clientX+'px'; pointer.style.top=ev.clientY+'px';
    if(drawing && mode==='pen' && drawPlane && currentLine){
      const ray=getRay(ev.clientX,ev.clientY);
      const pt=new THREE.Vector3(); ray.ray.intersectPlane(drawPlane,pt);
      if(pt){
        clampToParallelepiped(pt);
        const last=currentLine.points[currentLine.points.length-1];
        if(!last || last.distanceTo(pt)>0.01){
          currentLine.points.push(pt.clone());
          addPointToLineObj(currentLine,currentLine.points);
        }
      }
    }
  }

  function onPointerDown(ev){
    if(ev.button!==0) return;
    const ray=getRay(ev.clientX,ev.clientY);
    if(mode==='pen'){
      if(!planeFixed || !drawPlane){
        const camDir=new THREE.Vector3(); camera.getWorldDirection(camDir);
        drawPlane=new THREE.Plane().setFromNormalAndCoplanarPoint(camDir,new THREE.Vector3());
        planeFixed=true;
      }
      const pt=new THREE.Vector3(); ray.ray.intersectPlane(drawPlane,pt);
      if(!pt) return;
      clampToParallelepiped(pt);
      const lineObj=makeLineObject([pt.clone()], colorPicker.value, parseInt(thicknessInput.value,10));
      currentLine={ points:[pt.clone()], object3d:lineObj.object3d, material:lineObj.material, id:nextId++ };
      lines.push(currentLine);
      threeScene.add(currentLine.object3d);
      drawing=true;
    }
    if(mode==='eraser'){
      const pt=new THREE.Vector3(); ray.ray.intersectPlane(new THREE.Plane(new THREE.Vector3(0,0,1),0),pt);
      if(!pt) return;
      const r=parseFloat(eraserSizeInput.value);
      for(let i=lines.length-1;i>=0;i--){
        const l=lines[i];
        if(l.points.some(p=>p.distanceTo(pt)<r)){
          threeScene.remove(l.object3d);
          lines.splice(i,1);
        }
      }
    }
  }

  function onPointerUp(ev){ drawing=false; currentLine=null; }

  renderer.domElement.addEventListener('pointerdown', onPointerDown);
  renderer.domElement.addEventListener('pointermove', onPointerMove);
  renderer.domElement.addEventListener('pointerup', onPointerUp);
  renderer.domElement.addEventListener('pointerleave', onPointerUp);

  renderer.setAnimationLoop(()=>{
    renderer.render(threeScene,camera);
  });

});
</script>
</body>
</html>
