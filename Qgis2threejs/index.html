<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>terremoti-07-2025</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<base target="_blank">
<link rel="stylesheet" type="text/css" href="./Qgis2threejs.css">
<style type="text/css">
#popup, #header, #layerpanel {
  left: 36px;
}
.label2d {
  padding:2px 6px;
  background:rgba(255,255,255,0.95);
  border:1px solid #000;
  color:#000;
  font-weight:700;
  font-size:12px;
  border-radius:3px;
  white-space:nowrap;
  pointer-events:none;
  position:absolute;
  transform:translate(-50%,-50%);
}
</style>
<script src="./threejs/three.min.js"></script>
<script src="./threejs/OrbitControls.js"></script>
<script src="./threejs/ViewHelper.js"></script>
<script src="./threejs/OutlineEffect.js"></script>
<script src="./Qgis2threejs.js"></script>
</head>
<body>
<div id="view">
  <div id="northarrow"></div>
  <div id="navigation"></div>
</div>
<!-- popup -->
<div id="popup">
  <div id="closebtn">&times;</div>
  <div id="popupbar"></div>
  <div id="popupbody">
    <div id="popupcontent"></div>
    <!-- query result -->
    <div id="queryresult">
      <table id="qr_coords_table">
        <caption>Clicked coordinates <div id="zoomtopoint" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_coords"></td></tr>
      </table>
      <table id="qr_layername_table">
        <caption>Layer <div id="zoomtolayer" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_layername"></td></tr>
      </table>
      <table id="qr_attrs_table">
        <caption>Attributes</caption>
      </table>
      <!-- camera actions and measure tool -->
      <div id="orbitbtn" class="action-btn action-orbit">Orbit</div>
      <div id="measurebtn" class="action-btn">Measure distance</div>
    </div>
    <!-- page info -->
    <div id="pageinfo">
      <h1>Current View URL</h1>
      <div><input id="urlbox" type="text"></div>
      <h1>Usage</h1>
      <table id="usage">
        <tr><td colspan="2" class="star">Mouse</td></tr>
        <tr><td>Left button + Move</td><td>Orbit</td></tr>
        <tr><td>Mouse Wheel</td><td>Zoom</td></tr>
        <tr><td>Right button + Move</td><td>Pan</td></tr>
        <tr><td colspan="2" class="star">Keys</td></tr>
        <tr><td>Arrow keys</td><td>Move Horizontally</td></tr>
        <tr><td>Shift + Arrow keys</td><td>Orbit</td></tr>
        <tr><td>Ctrl + Arrow keys</td><td>Rotate</td></tr>
        <tr><td>Shift + Ctrl + Up / Down</td><td>Zoom In / Out</td></tr>
        <tr><td>L</td><td>Toggle Label Visibility</td></tr>
        <tr><td>R</td><td>Start / Stop Orbit Animation</td></tr>
        <tr><td>W</td><td>Wireframe Mode</td></tr>
        <tr><td>Shift + R</td><td>Reset Camera Position</td></tr>
        <tr><td>Shift + S</td><td>Save Image</td></tr>
      </table>
      <h1>About</h1>
      <div id="about"><img src="./Qgis2threejs.png">
        This page was made with <a href="https://www.qgis.org/">QGIS</a> and <a href="https://github.com/minorua/Qgis2threejs">Qgis2threejs</a> plugin (version 2.8).
        <div>Powered by <a href="https://threejs.org/">three.js</a>
        <span id="lib_proj4js"> and <a href="https://trac.osgeo.org/proj4js/">Proj4js</a></span>.</div>
      </div>
    </div>
  </div>
</div>
<!-- progress bar -->
<div id="progress"><div id="progressbar"></div></div>
<!-- menu -->
<div id="toolbtns">
  <div id="layerbtn"></div>
  <div id="animbtn" class="hidden"></div>
  <div id="infobtn"></div>
</div>
<!-- header and footer -->
<div id="header"></div>
<div id="footer"></div>
<!-- layer panel -->
<div id="layerpanel">
  <div id="layerlist"></div>
</div>
<!-- animation -->
<div id="narrativebox" class="ef1">
  <div id="narbody">
  </div>
  <div id="nextbtn"></div>
</div>
<script>
// Configurazione iniziale
Q3D.Config.allVisible = true;
Q3D.Config.bgColor = 0xffffff;
Q3D.Config.viewpoint = {
  lookAt: {x: 426248.434989865, y: 4517666.811603576, z: -1.1839921050606837e-15},
  pos: {x: 432420.6401290015, y: 4504911.042410877, z: 3937.8688261482375}
};
Q3D.Config.localMode = true;

// Inizializzazione
var container = document.getElementById("view"),
    app = Q3D.application,
    gui = Q3D.gui;

console.log('Inizializzazione dell\'applicazione...');
try {
  app.init(container);       // initialize viewer
  console.log('Applicazione inizializzata correttamente.');
} catch (error) {
  console.error('Errore durante l\'inizializzazione dell\'applicazione:', error);
}

console.log('Caricamento del file della scena...');
try {
  app.loadSceneFile("./data/index/scene.js",
    function(scene) {
      console.log('File della scena caricato:', scene);
      try {
        app.start();
        console.log('Applicazione avviata.');
      } catch (error) {
        console.error('Errore durante l\'avvio dell\'applicazione:', error);
      }
    },
    function(scene) {
      console.log('Tutti i file rilevanti sono stati caricati:', scene);
      try {
        const THREE = window.THREE;
        const threeScene = (scene && scene.isScene) ? scene : (app && app.scene) || window.scene;
        const camera = (app && app.camera) || window.camera || (window.viewer && viewer.camera);
        const renderer = (app && app.renderer) || window.renderer || (window.viewer && viewer.renderer);

        console.log('Callback all files loaded - scene, camera, renderer:', !!threeScene, !!camera, !!renderer);
        if (!THREE || !threeScene || !camera || !renderer) {
          console.warn('Ambiente rendering non disponibile nel callback (THREE/scene/camera/renderer).');
          return;
        }

        // Cerca il layer DTM usando il layerId: 2
        let dtm = null;

        // Cerca in tutta la scena
        threeScene.traverse(function(object) {
          if (object.userData && object.userData.layerId === 2) {
            dtm = object;
            console.log('Layer DTM trovato con layerId: 2', object.name || 'no name');
          }
        });

        if (!dtm) {
          console.error('Impossibile trovare il layer DTM con layerId: 2');
          return;
        }

        console.log('Layer DTM trovato:', dtm.name || 'no name');

        // Crea lo stile per le etichette se non esiste già
        if (!document.getElementById('label2d-style')) {
          const s = document.createElement('style');
          s.id = 'label2d-style';
          s.textContent = `
          .label2d {
            padding:2px 6px;
            background:rgba(255,255,255,0.95);
            border:1px solid #000;
            color:#000;
            font-weight:700;
            font-size:12px;
            border-radius:3px;
            white-space:nowrap;
            pointer-events:none;
            position:absolute;
            transform:translate(-50%,-50%);
          }`;
          document.head.appendChild(s);
        }

        // Rendi il DTM sempre visibile
        dtm.traverse(n => {
          if (n.isMesh) {
            const mats = Array.isArray(n.material) ? n.material : [n.material];
            for (const m of mats) {
              if (!m) continue;
              if (typeof m.opacity !== 'number' || m.opacity === 1) m.opacity = 0.6;
              m.transparent = true;
              m.depthTest = false;
              m.depthWrite = false;
              m.side = THREE.DoubleSide;
              m.needsUpdate = true;
            }
            n.renderOrder = 999;
          }
        });

        // Calcola il bounding box del DTM
        const bb = new THREE.Box3().setFromObject(dtm);
        console.log('Bounding box del DTM:', bb);

        // Determina l'asse verticale (Z di default)
        let vertIndex = 2; // Assumiamo Z come asse verticale per default

        // Verifichiamo se la dimensione Z è effettivamente la più piccola (tipico per i DTM)
        const size = bb.getSize(new THREE.Vector3());
        console.log('Dimensioni del DTM:', size.x, size.y, size.z);

        // Se Z non è la dimensione più piccola, forse l'asse verticale è diverso
        const minDimIndex = (size.x < size.y) ?
                          ((size.x < size.z) ? 0 : 2) :
                          ((size.y < size.z) ? 1 : 2);
        vertIndex = minDimIndex;
        console.log('Asse verticale identificato:', ['X','Y','Z'][vertIndex]);

        // Estrai gli assi orizzontali
        const axes2 = [0,1,2].filter(i => i !== vertIndex);
        console.log('Assi orizzontali:', axes2.map(i => ['X','Y','Z'][i]).join(', '));

        // Estrai i valori minimi e massimi per gli assi orizzontali e verticale
        const minA = bb.min.getComponent(axes2[0]);
        const maxA = bb.max.getComponent(axes2[0]);
        const minB = bb.min.getComponent(axes2[1]);
        const maxB = bb.max.getComponent(axes2[1]);
        const minZ = bb.min.getComponent(vertIndex);
        const maxZ = bb.max.getComponent(vertIndex);

        console.log('Estremi del DTM:');
        console.log(' - Asse 1 (min/max):', minA, maxA);
        console.log(' - Asse 2 (min/max):', minB, maxB);
        console.log(' - Asse Z (min/max):', minZ, maxZ);

        // Definisci la profondità del parallelepipedo
        const DEPTH = 10000; // Profondità totale in metri
        const STEP = 1000;   // Intervallo tra le etichette
        const OFFSET_PX = 30; // Offset per le etichette

        // Il livello 0 metri deve corrispondere al punto in basso a destra della mappa
        // Per una mappa vista dall'alto (DTM), il "livello 0" corrisponde alla quota minima del DTM
        const baseZ = minZ; // Il livello 0 è la quota minima del DTM
        const topZ = maxZ; // La quota massima del DTM

        // Ma se vogliamo che il parallelepipedo parta dalla base del DTM e vada verso il basso,
        // dobbiamo considerare che il livello 0 è alla base del DTM, e il parallelepipedo va verso il basso
        // Quindi:
        // - La parte superiore del parallelepipedo è alla quota massima del DTM (maxZ)
        // - La parte inferiore è a maxZ - DEPTH

        // Ma secondo la richiesta, il livello 0 metri deve corrispondere al punto in basso a destra
        // della mappa (DTM). Quindi dobbiamo interpretare correttamente cosa si intende per "livello 0 metri".

        // Interpretazione: il "livello 0 metri" è la quota minima del DTM (poiché il DTM è una superficie,
        // la sua quota minima può essere considerata il livello di riferimento)
        const referenceZ = minZ; // Livello 0 metri = quota minima del DTM

        // Il parallelepipedo deve partire dal livello 0 metri (referenceZ) e scendere fino a referenceZ - DEPTH
        const bottomZ = referenceZ - DEPTH;
        const topZParallelepiped = referenceZ; // Il "top" del parallelepipedo è al livello 0 metri
        // Ma questo non ha senso, perché il parallelepipedo dovrebbe scendere sotto il DTM.
        // Forse intendevamo che il livello 0 metri è il piano di riferimento (quota 0),
        // e il DTM si trova sopra questo piano.

        // Cerchiamo di capire meglio:
        // Il DTM è una superficie 3D che rappresenta la topografia.
        // Il "livello 0 metri" potrebbe essere:
        // 1. Il piano z=0 nel sistema di coordinate (ma il DTM potrebbe essere sopra o sotto questo piano)
        // 2. Il punto più basso del DTM (minZ)
        // 3. Il piano che passa per il punto in basso a destra del DTM

        // Dalla richiesta: "il parallelepipedo... il cui livello 0 metri è il punto in basso a destra della mappa"
        // Questo suggerisce che il livello 0 metri è la quota del punto in basso a destra del DTM.

        // Quindi:
        // 1. Troviamo il punto in basso a destra del DTM (minA, minB, ?)
        // Per una superficie 2D vista dall'alto, il "basso a destra" è:
        // - max dell'asse X (se X è orizzontale)
        // - min dell'asse Y (se Y è orizzontale)
        // - la Z di quel punto

        // Otteniamo la quota Z del punto in basso a destra del DTM
        const bottomRightPoint = new THREE.Vector3();
        bottomRightPoint.setComponent(axes2[0], maxA);
        bottomRightPoint.setComponent(axes2[1], minB);

        // Ma abbiamo bisogno della Z di quel punto. Per un mesh, dobbiamo trovare il vertice corrispondente.
        // Per una superficie, possiamo usare la quota al punto (maxA, minB)
        // Ma poiché il DTM è una mesh, possiamo usare un raycaster per trovare la quota in quel punto,
        // oppure assumere che la quota minima (minZ) rappresenti il livello 0 metri.

        // Per semplicità, useremo minZ come riferimento per il livello 0 metri,
        // ma dobbiamo trovare la Z esatta nel punto in basso a destra.

        // Per trovare la Z esatta nel punto (maxA, minB):
        // 1. Creiamo un raggio verticale in quel punto
        // 2. Intersechiamo con la mesh del DTM per trovare la quota

        // Ma questo potrebbe essere complesso. Alternativa:
        // Usare minZ come livello di riferimento (livello 0 metri)
        // Oppure assumere che il livello 0 metri sia la quota media del DTM

        // Per ora, assumiamo che il livello 0 metri sia la quota minima del DTM (minZ)
        const referenceLevel = minZ; // Livello 0 metri = quota minima del DTM
        const topZParallelepiped = referenceLevel; // Il "top" del parallelepipedo è al livello 0 metri
        const bottomZParallelepiped = referenceLevel - DEPTH; // Profondità sotto il livello 0 metri

        // Definiamo i vertici del parallelepipedo
        const topCornersCorrect = [
          new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], minB).setComponent(vertIndex, topZParallelepiped), // angolo in basso a destra (che sarà il livello 0)
          new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], maxB).setComponent(vertIndex, topZParallelepiped), // angolo in basso a sinistra
          new THREE.Vector3().setComponent(axes2[0], minA).setComponent(axes2[1], maxB).setComponent(vertIndex, topZParallelepiped), // angolo in alto a sinistra
          new THREE.Vector3().setComponent(axes2[0], minA).setComponent(axes2[1], minB).setComponent(vertIndex, topZParallelepiped)  // angolo in alto a destra
        ];

        // Vertici inferiori del parallelepipedo (a bottomZParallelepiped)
        const bottomCorners = topCornersCorrect.map(c => c.clone().setComponent(vertIndex, bottomZParallelepiped));

        // Materiale per le linee del parallelepipedo
        const matLine = new THREE.LineBasicMaterial({
          color: 0x000000,
          linewidth: 2,
          opacity: 0.8,
          transparent: true
        });

        // Funzione per aggiungere una linea tra due punti
        function addLine(p1, p2) {
          const geom = new THREE.BufferGeometry().setFromPoints([p1.clone(), p2.clone()]);
          const l = new THREE.Line(geom, matLine);
          threeScene.add(l);
          return l;
        }

        // Disegna il parallelepipedo
        console.log('Disegno del parallelepipedo...');

        // Lati superiori (orizzontali)
        for (let i = 0; i < 4; i++) {
          addLine(topCornersCorrect[i], topCornersCorrect[(i+1)%4]);
        }

        // Lati inferiori (orizzontali)
        for (let i = 0; i < 4; i++) {
          addLine(bottomCorners[i], bottomCorners[(i+1)%4]);
        }

        // Lati verticali
        for (let i = 0; i < 4; i++) {
          addLine(topCornersCorrect[i], bottomCorners[i]);
        }

        // Etichette sulla colonna in alto a destra
        const labels = [];

        // Il punto in alto a destra è topCornersCorrect[3] (perché abbiamo definito i vertici in ordine orario)
        const topRightCorner = topCornersCorrect[3].clone(); // angolo in alto a destra
        const bottomRightCorner = bottomCorners[3].clone(); // angolo in basso a destra

        // La direzione verticale è data dall'asse verticale
        // Per posizionare le etichette, dobbiamo trovare un punto leggermente dentro rispetto al bordo
        // Possiamo usare una direzione che va dal centro verso l'angolo

        // Calcola il centro della base (proiezione 2D)
        const centerFoot = new THREE.Vector3();
        centerFoot.setComponent(axes2[0], (maxA + minA) / 2);
        centerFoot.setComponent(axes2[1], (maxB + minB) / 2);
        centerFoot.setComponent(vertIndex, 0);

        // Direzione dal centro verso l'angolo in alto a destra (per posizionare le etichette)
        const dirOut = topRightCorner.clone().setComponent(vertIndex, 0).sub(centerFoot.clone().setComponent(vertIndex, 0));
        if (dirOut.lengthSq() < 1e-6) {
          // Se la direzione è quasi nulla, usiamo un vettore arbitrario verso l'esterno
          dirOut.setComponent(axes2[0], 1);
          dirOut.setComponent(axes2[1], 0);
        }
        dirOut.setComponent(vertIndex, 0);
        dirOut.normalize();

        // Calcola la dimensione del footprint (base) per l'offset delle etichette
        const footprintSize = Math.max(
          bb.getSize(new THREE.Vector3()).getComponent(axes2[0]),
          bb.getSize(new THREE.Vector3()).getComponent(axes2[1])
        );

        const labelOffset = OFFSET_PX * 0.01 * footprintSize;

        // Posizione delle etichette: lungo la colonna verticale passante per l'angolo in alto a destra
        // Ma dobbiamo posizionarle all'interno del parallelepipedo, non all'esterno
        // Quindi usiamo una direzione verso l'interno (opposta a dirOut)
        const dirIn = dirOut.clone().negate();

        // Crea le etichette ogni STEP metri lungo la colonna verticale
        for (let d = 0; d <= DEPTH; d += STEP) {
          const z = topZParallelepiped - d;
          const pos = topRightCorner.clone().setComponent(vertIndex, z);

          // Sposta il punto verso l'interno del parallelepipedo
          const posIn = pos.clone().add(dirIn.clone().multiplyScalar(labelOffset));

          const div = document.createElement('div');
          div.className = 'label2d';
          div.textContent = `-${d} m`;
          div.style.zIndex = '1000'; // Assicurati che le etichette siano sopra tutto
          document.body.appendChild(div);

          // Salva il punto 3D e l'elemento DOM per l'aggiornamento
          labels.push({
            el: div,
            pos: posIn.clone()
          });
        }

        // Funzione per aggiornare la posizione delle etichette
        function updateLabels() {
          requestAnimationFrame(updateLabels);
          try {
            for (const L of labels) {
              const p = L.pos.clone().project(camera);
              if (p.z < -1 || p.z > 1) {
                L.el.style.display = 'none';
                continue;
              }
              const sx = (p.x + 1) * 0.5 * renderer.domElement.clientWidth;
              const sy = (1 - p.y) * 0.5 * renderer.domElement.clientHeight;
              L.el.style.display = '';
              L.el.style.left = Math.round(sx) + 'px';
              L.el.style.top = Math.round(sy) + 'px';
            }
          } catch (e) {
            // Ignora gli errori di aggiornamento delle etichette
          }
        }
        updateLabels(); // Avvia il ciclo di aggiornamento

        console.log('Parallelepipedo e etichette aggiunti con successo.');

      } catch (err) {
        console.error('Errore nel callback parallelepipedo:', err);
      }
    }
  );
} catch (error) {
  console.error('Errore durante il caricamento del file della scena:', error);
}
</script>
</body>
</html>
