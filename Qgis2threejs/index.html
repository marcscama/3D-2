<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>terremoti-07-2025</title>
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<base target="_blank">
<link rel="stylesheet" type="text/css" href="./Qgis2threejs.css">
<style type="text/css">
#popup, #header, #layerpanel {
  left: 36px;
}
</style>
<script src="./threejs/three.min.js"></script>
<script src="./threejs/OrbitControls.js"></script>
<script src="./threejs/ViewHelper.js"></script>
<script src="./threejs/OutlineEffect.js"></script>
<script src="./Qgis2threejs.js"></script>
</head>

<!-- Inserisci questo codice prima di </body> nel file index.html esportato da Qgis2threejs -->
<style>
/* mantiene esattamente lo stile delle etichette che usiamo */
.label2d {
  padding:2px 6px;
  background:rgba(255,255,255,0.95);
  border:1px solid #000;
  color:#000;
  font-weight:700;
  font-size:12px;
  border-radius:3px;
  white-space:nowrap;
  pointer-events:none;
  position: absolute;
  transform: translate(-50%, -50%);
  will-change: transform;
}
</style>

<script>
(function(){

  // --- CONFIG ---
  const DEPTH = 10000;        // profondità (m) -> top (surface) a top - DEPTH
  const LABEL_STEP = 1000;    // step delle etichette
  const LABEL_OFFSET_PX = 30; // distanza etichette in "unità relative" (vedi calcolo)
  // -------------

  // Attende che il viewer Qgis2threejs sia pronto (scene, camera, renderer globali)
  function waitForViewer(timeout = 8000) {
    return new Promise((resolve, reject) => {
      const start = Date.now();
      (function tick(){
        if (window.THREE && (window.scene || (window.viewer && window.viewer.scene)) && (window.camera || (window.viewer && window.viewer.camera)) && (window.renderer || (window.viewer && window.viewer.renderer))) {
          const s = window.scene || (window.viewer && window.viewer.scene);
          const c = window.camera || (window.viewer && window.viewer.camera);
          const r = window.renderer || (window.viewer && window.viewer.renderer);
          return resolve({ THREE: window.THREE, scene: s, camera: c, renderer: r });
        }
        if (Date.now() - start > timeout) return reject(new Error('Viewer non trovato (scene/camera/renderer). Incolla questo script DOPO gli script di Qgis2threejs).'));
        requestAnimationFrame(tick);
      }());
    });
  }

  function findDTM(scene, THREE) {
    // by name
    if (scene.getObjectByName) {
      const byName = scene.getObjectByName('DTM');
      if (byName) return byName;
    }
    // contains 'dtm'
    let found = null;
    scene.traverse(obj => {
      if (!found && obj.isMesh && obj.name && typeof obj.name === 'string' && obj.name.toLowerCase().includes('dtm')) found = obj;
    });
    if (found) return found;
    // fallback: largest footprint mesh
    let maxArea = -Infinity, best = null;
    scene.traverse(obj => {
      if (obj.isMesh) {
        const bb = new THREE.Box3().setFromObject(obj);
        const s = new THREE.Vector3(); bb.getSize(s);
        const arr = [s.x, s.y, s.z].sort((a,b)=>b-a);
        const area = arr[0]*arr[1];
        if (area > maxArea) { maxArea = area; best = obj; }
      }
    });
    return best;
  }

  // screen project
  function projectToScreen(pos3, camera, renderer) {
    const width = renderer.domElement.clientWidth;
    const height = renderer.domElement.clientHeight;
    const p = pos3.clone().project(camera);
    return {
      x: (p.x + 1) * 0.5 * width,
      y: (1 - p.y) * 0.5 * height,
      z: p.z
    };
  }

  // create DOM label
  function createLabelDOM(text, pos3) {
    const div = document.createElement('div');
    div.className = 'label2d';
    div.textContent = text;
    document.body.appendChild(div);
    return { el: div, pos: pos3.clone() };
  }

  waitForViewer().then(({THREE, scene, camera, renderer}) => {

    const dtm = findDTM(scene, THREE);
    if (!dtm) { console.warn('DTM non trovato nella scena.'); return; }

    // forza DTM sempre visibile (semi-trasparente)
    dtm.traverse(m => {
      if (m.isMesh) {
        const mats = Array.isArray(m.material) ? m.material : [m.material];
        for (const mat of mats) {
          if (!mat) continue;
          if (typeof mat.opacity !== 'number' || mat.opacity === 1) mat.opacity = 0.6;
          mat.transparent = true;
          mat.depthTest = false;
          mat.depthWrite = false;
          mat.side = THREE.DoubleSide;
          mat.needsUpdate = true;
        }
        m.renderOrder = 999;
      }
    });

    // bbox del DTM
    const bb = new THREE.Box3().setFromObject(dtm);

    // determina asse verticale come la dimensione minore del bbox globale
    const totalBbox = new THREE.Box3().setFromObject(scene);
    const totalSize = new THREE.Vector3(); totalBbox.getSize(totalSize);
    let vertIndex = 1;
    if (totalSize.x <= totalSize.y && totalSize.x <= totalSize.z) vertIndex = 0;
    else if (totalSize.z <= totalSize.x && totalSize.z <= totalSize.y) vertIndex = 2;
    const axes2 = [0,1,2].filter(i=>i!==vertIndex);

    // punto 2D "basso a destra" = (max su axes2[0], min su axes2[1])
    const maxA = bb.max.getComponent(axes2[0]);
    const minB = bb.min.getComponent(axes2[1]);

    // quota di superficie: bbox.max sul vertIndex
    const topZ = bb.max.getComponent(vertIndex);
    const bottomZ = topZ - DEPTH;

    // top corners (0=basso-destra,1=alto-destra,2=alto-sin,3=basso-sin)
    const topCorners = [];
    topCorners.push(new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], minB).setComponent(vertIndex, topZ));
    topCorners.push(new THREE.Vector3().setComponent(axes2[0], maxA).setComponent(axes2[1], bb.max.getComponent(axes2[1])).setComponent(vertIndex, topZ));
    topCorners.push(new THREE.Vector3().setComponent(axes2[0], bb.min.getComponent(axes2[0])).setComponent(axes2[1], bb.max.getComponent(axes2[1])).setComponent(vertIndex, topZ));
    topCorners.push(new THREE.Vector3().setComponent(axes2[0], bb.min.getComponent(axes2[0])).setComponent(axes2[1], minB).setComponent(vertIndex, topZ));

    const bottomCorners = topCorners.map(c => c.clone().setComponent(vertIndex, bottomZ));

    // disegna contorni: top rect, bottom rect, verticali (12 linee)
    const matLine = new THREE.LineBasicMaterial({ color: 0x000000 });
    function addLine(p1,p2){ const geom = new THREE.BufferGeometry().setFromPoints([p1.clone(), p2.clone()]); const l = new THREE.Line(geom, matLine); scene.add(l); return l; }
    addLine(topCorners[0], topCorners[1]); addLine(topCorners[1], topCorners[2]);
    addLine(topCorners[2], topCorners[3]); addLine(topCorners[3], topCorners[0]);
    addLine(bottomCorners[0], bottomCorners[1]); addLine(bottomCorners[1], bottomCorners[2]);
    addLine(bottomCorners[2], bottomCorners[3]); addLine(bottomCorners[3], bottomCorners[0]);
    for (let i=0;i<4;i++) addLine(topCorners[i], bottomCorners[i]);

    // etichette SOLO sulla colonna in basso-destra (topCorners[0] -> bottomCorners[0])
    const labels = [];
    const cornerTop = topCorners[0].clone();
    const centerFoot = new THREE.Vector3();
    centerFoot.setComponent(axes2[0], (bb.max.getComponent(axes2[0]) + bb.min.getComponent(axes2[0]))/2);
    centerFoot.setComponent(axes2[1], (bb.max.getComponent(axes2[1]) + bb.min.getComponent(axes2[1]))/2);
    centerFoot.setComponent(vertIndex, 0);
    const dirOut = cornerTop.clone().setComponent(vertIndex, 0).sub(centerFoot.clone().setComponent(vertIndex,0));
    if (dirOut.lengthSq() < 1e-6) { dirOut.setComponent(axes2[0],1); dirOut.setComponent(axes2[1],0); }
    dirOut.setComponent(vertIndex,0); dirOut.normalize();

    // Scala offset in funzione della dimensione della footprint per ottenere un offset visibile
    const footprintSize = Math.max( bb.getSize(new THREE.Vector3()).x, bb.getSize(new THREE.Vector3()).y );
    const labelOffset = LABEL_OFFSET_PX * 0.01 * footprintSize;

    for (let d = LABEL_STEP; d <= DEPTH; d += LABEL_STEP) {
      const z = topZ - d;
      const pos = cornerTop.clone().setComponent(vertIndex, z);
      const posOut = pos.clone().add(dirOut.clone().multiplyScalar(labelOffset));
      labels.push(createLabelDOM(`-${d} m`, posOut));
    }

    // aggiorna posizione label ogni frame
    function updateLabels(){
      for (const L of labels){
        const screen = projectToScreen(L.pos, camera, renderer);
        if (screen.z < -1 || screen.z > 1) { L.el.style.display = 'none'; }
        else {
          L.el.style.display = '';
          L.el.style.left = Math.round(screen.x) + 'px';
          L.el.style.top  = Math.round(screen.y) + 'px';
        }
      }
    }

    (function loop(){ requestAnimationFrame(loop); try{ updateLabels(); }catch(e){} })();

    console.log('Parallelepipedo aggiunto: top=', topZ, ' bottom=', bottomZ, ' cornerXY=', maxA, minB);

    // Se vuoi traslare l'intera scena in modo che surface diventi Z=0 nella scena globale,
    // decommenta la riga seguente (attenzione: sposta TUTTI i layer):
    // scene.position && scene.position.setComponent(vertIndex, (scene.position.getComponent(vertIndex)||0) - topZ);

  }).catch(err => { console.error(err); alert('Viewer non trovato — incolla questo script DOPO gli scripts di Qgis2threejs.'); });

})();
</script>

  
<body>
<div id="view">
  <div id="northarrow"></div>
  <div id="navigation"></div>
</div>

<!-- popup -->
<div id="popup">
  <div id="closebtn">&times;</div>
  <div id="popupbar"></div>
  <div id="popupbody">
    <div id="popupcontent"></div>

    <!-- query result -->
    <div id="queryresult">
      <table id="qr_coords_table">
        <caption>Clicked coordinates <div id="zoomtopoint" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_coords"></td></tr>
      </table>

      <table id="qr_layername_table">
        <caption>Layer <div id="zoomtolayer" class="action-zoom zoombtn"></div></caption>
        <tr><td id="qr_layername"></td></tr>
      </table>

      <table id="qr_attrs_table">
        <caption>Attributes</caption>
      </table>

      <!-- camera actions and measure tool -->
      <div id="orbitbtn" class="action-btn action-orbit">Orbit</div>
      <div id="measurebtn" class="action-btn">Measure distance</div>
    </div>

    <!-- page info -->
    <div id="pageinfo">
      <h1>Current View URL</h1>
      <div><input id="urlbox" type="text"></div>

      <h1>Usage</h1>
      <table id="usage">
        <tr><td colspan="2" class="star">Mouse</td></tr>
        <tr><td>Left button + Move</td><td>Orbit</td></tr>
        <tr><td>Mouse Wheel</td><td>Zoom</td></tr>
        <tr><td>Right button + Move</td><td>Pan</td></tr>

        <tr><td colspan="2" class="star">Keys</td></tr>
        <tr><td>Arrow keys</td><td>Move Horizontally</td></tr>
        <tr><td>Shift + Arrow keys</td><td>Orbit</td></tr>
        <tr><td>Ctrl + Arrow keys</td><td>Rotate</td></tr>
        <tr><td>Shift + Ctrl + Up / Down</td><td>Zoom In / Out</td></tr>
        <tr><td>L</td><td>Toggle Label Visibility</td></tr>
        <tr><td>R</td><td>Start / Stop Orbit Animation</td></tr>
        <tr><td>W</td><td>Wireframe Mode</td></tr>
        <tr><td>Shift + R</td><td>Reset Camera Position</td></tr>
        <tr><td>Shift + S</td><td>Save Image</td></tr>
      </table>

      <h1>About</h1>
      <div id="about"><img src="./Qgis2threejs.png">
        This page was made with <a href="https://www.qgis.org/">QGIS</a> and <a href="https://github.com/minorua/Qgis2threejs">Qgis2threejs</a> plugin (version 2.8).
        <div>Powered by <a href="https://threejs.org/">three.js</a>
        <span id="lib_proj4js"> and <a href="https://trac.osgeo.org/proj4js/">Proj4js</a></span>.</div>
      </div>
    </div>
  </div>
</div>

<!-- progress bar -->
<div id="progress"><div id="progressbar"></div></div>

<!-- menu -->
<div id="toolbtns">
  <div id="layerbtn"></div>
  <div id="animbtn" class="hidden"></div>
  <div id="infobtn"></div>
</div>

<!-- header and footer -->
<div id="header"></div>
<div id="footer"></div>

<!-- layer panel -->
<div id="layerpanel">
  <div id="layerlist"></div>
</div>

<!-- animation -->
<div id="narrativebox" class="ef1">
  <div id="narbody">

  </div>
  <div id="nextbtn"></div>
</div>

<script>
Q3D.Config.allVisible = true;
Q3D.Config.bgColor = 0xffffff;
Q3D.Config.viewpoint = {lookAt:{x:426248.434989865,y:4517666.811603576,z:-1.1839921050606837e-15},pos:{x:432420.6401290015,y:4504911.042410877,z:3937.8688261482375}};
Q3D.Config.localMode = true;

var container = document.getElementById("view"),
    app = Q3D.application,
    gui = Q3D.gui;

app.init(container);       // initialize viewer

// load the scene
app.loadSceneFile("./data/index/scene.js", function (scene) {
  // scene file has been loaded
  app.start();
}, function (scene) {
  // all relevant files have been loaded

});
</script>
</body>
</html>
